<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>synth.html v0.7.0</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: #0a0a0a;
    background-image: repeating-linear-gradient(90deg, transparent, transparent 19px, #141414 19px, #141414 20px);
    color: #e0e0e0;
    font-family: 'Share Tech Mono', 'IBM Plex Mono', monospace;
    font-size: 12px; overflow: hidden; height: 100vh;
  }
  #toolbar {
    position: fixed; top: 0; left: 0; right: 0; height: 44px;
    background: #080808; border-bottom: 1px solid #1c1c1c;
    display: flex; align-items: center; padding: 0 16px; gap: 8px; z-index: 100;
    box-shadow: 0 2px 12px rgba(0,0,0,0.9);
  }
  .logo { font-size: 12px; font-weight: 700; color: #00c853; letter-spacing: 3px; margin-right: 16px; text-transform: uppercase; }
  .tb-btn {
    background: #111; border: 1px solid #2a2a2a; color: #888;
    padding: 4px 14px; border-radius: 2px; cursor: pointer;
    font-family: 'Share Tech Mono', monospace; font-size: 10px; transition: all 0.15s;
    text-transform: uppercase; letter-spacing: 1px;
  }
  .tb-btn:hover { background: #1a1a1a; border-color: #444; color: #aaa; }
  .tb-btn.play { border-color: #00c853; color: #00c853; }
  .tb-btn.play:hover { background: #00c85318; }
  .tb-btn.stop { border-color: #ff1744; color: #ff1744; display: none; }
  .tb-btn.stop:hover { background: #ff174418; }
  .tb-select {
    background: #111; border: 1px solid #2a2a2a; color: #888;
    padding: 4px 8px; border-radius: 2px; font-family: 'Share Tech Mono', monospace; font-size: 10px;
    cursor: pointer; outline: none;
  }
  .tb-sep { width: 1px; height: 24px; background: #1c1c1c; margin: 0 4px; }
  #node-palette {
    position: fixed; top: 44px; left: 0; width: 180px; bottom: 0;
    background: #0c0c0c;
    border-right: 2px solid #181818;
    padding: 12px 8px 110px; overflow-y: auto; z-index: 50;
    box-shadow: inset -4px 0 12px rgba(0,0,0,0.6);
  }
  .palette-section { margin-bottom: 20px; }
  .palette-label {
    font-size: 7px; letter-spacing: 3px; text-transform: uppercase; color: #2a2a2a;
    margin-bottom: 8px; padding: 0 4px 4px;
    border-bottom: 1px solid #1a1a1a;
  }
  .palette-item {
    background: #0f0f0f; border: 1px solid #1e1e1e; border-left: 3px solid;
    border-radius: 2px; padding: 8px 10px; margin-bottom: 4px;
    cursor: grab; transition: all 0.15s; user-select: none;
  }
  .palette-item:hover { background: #181818; transform: translateX(2px); border-color: #2a2a2a; }
  .palette-item .item-name { font-size: 10px; color: #bbb; text-transform: uppercase; letter-spacing: 1px; }
  .palette-item .item-desc { font-size: 8px; color: #3a3a3a; margin-top: 2px; }
  .pi-source { border-left-color: #00c853; }
  .pi-effect { border-left-color: #2979ff; }
  .pi-mod    { border-left-color: #ffab00; }
  .pi-sink   { border-left-color: #aa00ff; }
  #canvas-area {
    position: fixed; top: 44px; left: 180px; right: 0; bottom: 0; overflow: hidden;
    transform-origin: 0 0;
    background: #080808;
    /* Dot grid at HP intervals (16px √ó 24px) */
    background-image: radial-gradient(circle, rgba(52,52,52,0.85) 1px, transparent 1px);
    background-size: 16px 24px;
  }
  #canvas-area.panning { cursor: grab; }
  #canvas-area.panning:active { cursor: grabbing; }
  #svg-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
    z-index: 15; /* above nodes so jack tips render on top */
  }
  .edge-path { fill: none; stroke-width: 5; stroke-linecap: round; stroke-linejoin: round; opacity: 0.88; transition: opacity 0.15s, filter 0.15s; pointer-events: visibleStroke; cursor: grab; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.7)); }
  .edge-path:hover { opacity: 1; filter: drop-shadow(0 2px 6px rgba(255,255,255,0.15)); }
  .edge-shadow { fill: none; stroke-width: 7; stroke-linecap: round; opacity: 0.25; pointer-events: none; }
  .edge-tip { pointer-events: none; }
  .edge-hit { fill: none; stroke: transparent; stroke-width: 20; cursor: grab; pointer-events: stroke; }
  .edge-preview { fill: none; stroke: #aa00ff; stroke-width: 4; stroke-linecap: round; opacity: 0.5; pointer-events: none; }

  /* ‚îÄ‚îÄ Nodes ‚Äî Eurorack panels ‚îÄ‚îÄ */
  .node {
    position: absolute;
    background: #0d0d0d;
    border: 1px solid #242424;
    border-radius: 2px;
    min-width: 170px;
    box-shadow: 0 0 0 1px #000, 2px 4px 24px rgba(0,0,0,0.85), inset 0 1px 0 rgba(255,255,255,0.04);
    user-select: none; transition: box-shadow 0.2s;
    z-index: 5;
  }
  /* Rack handles ‚Äî top and bottom grip strips */
  .rack-handle {
    height: 10px;
    background: linear-gradient(to bottom, #1e1e1e, #161616);
    border-bottom: 1px solid #2a2a2a;
    display: flex; align-items: center; justify-content: center;
    cursor: grab; gap: 4px;
  }
  .rack-handle.bottom {
    background: linear-gradient(to top, #1e1e1e, #161616);
    border-bottom: none; border-top: 1px solid #2a2a2a;
  }
  .rack-handle::before, .rack-handle::after {
    content: ''; display: block;
    width: 24px; height: 3px;
    background: #2a2a2a; border-radius: 1px;
    box-shadow: inset 0 1px 1px rgba(0,0,0,0.8), 0 1px 0 rgba(255,255,255,0.04);
  }
  .node.selected { border-color: #aa00ff88; box-shadow: 0 0 0 1px #aa00ff44, 2px 4px 24px rgba(170,0,255,0.2); }
  .node.running  { box-shadow: 0 0 0 1px #00c85322, 0 0 18px rgba(0,200,83,0.12); }
  .node-header {
    padding: 8px 10px 6px;
    cursor: grab; display: flex; align-items: center; gap: 7px;
    background: #111; border-radius: 2px 2px 0 0;
    border-bottom: 2px solid #1a1a1a;
  }
  .node-header:active { cursor: grabbing; }
  /* Type-specific accent stripe */
  .node-source > .node-header { border-bottom-color: #00c853; }
  .node-effect > .node-header { border-bottom-color: #2979ff; }
  .node-mod    > .node-header { border-bottom-color: #ffab00; }
  .node-sink   > .node-header { border-bottom-color: #aa00ff; }
  .node-color-dot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; }
  .node-title {
    font-size: 9px; font-weight: 400; color: #ddd; flex: 1;
    letter-spacing: 3px; text-transform: uppercase; text-align: center;
    font-family: 'Share Tech Mono', monospace;
  }
  .delete-btn { background: none; border: none; color: #2a2a2a; cursor: pointer; font-size: 14px; line-height: 1; padding: 0 2px; transition: color 0.15s; }
  .delete-btn:hover { color: #ff1744; }
  .node-body { padding: 10px 12px 6px; }
  .param-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 7px; gap: 8px; }
  .param-label { font-size: 7px; color: #444; text-transform: uppercase; letter-spacing: 1.5px; flex-shrink: 0; }
  .param-input {
    background: #060606; border: 1px solid #1e1e1e; border-radius: 1px;
    color: #ffab00; font-family: 'Share Tech Mono', monospace; font-size: 11px; padding: 3px 7px;
    width: 76px; text-align: right; outline: none; transition: border-color 0.15s, color 0.15s;
    cursor: ns-resize; user-select: none; -moz-appearance: textfield;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.8);
  }
  .param-input:focus { border-color: #aa00ff; color: #fff; cursor: text; }
  .param-input:hover:not(:focus) { border-color: #2a2a2a; color: #ffc107; }
  /* Hide browser spinners */
  .param-input::-webkit-outer-spin-button,
  .param-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
  .param-select {
    background: #060606; border: 1px solid #1e1e1e; border-radius: 1px;
    color: #888; font-family: 'Share Tech Mono', monospace; font-size: 9px;
    padding: 2px 4px; width: 90px; outline: none; text-transform: uppercase; letter-spacing: 1px;
  }

  /* VU bar */
  .vu-bar { height: 5px; border-radius: 0; background: #080808; overflow: hidden; margin-top: 4px; border: 1px solid #1a1a1a; }
  .vu-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #00c853, #ffab00, #ff1744); transition: width 0.08s; }

  /* Oscilloscope canvas */
  .scope-canvas {
    display: block; background: #000810;
    border-radius: 1px; border: 1px solid #001a10;
    margin: 4px 0;
    box-shadow: inset 0 0 8px rgba(0,255,80,0.05);
    image-rendering: pixelated;
  }

  /* ‚îÄ‚îÄ Ports ‚Äî 3.5mm patch jacks ‚îÄ‚îÄ */
  .node-ports { display: flex; justify-content: space-between; padding: 6px 2px 8px; gap: 4px; }
  .ports-in, .ports-out { display: flex; flex-direction: column; gap: 8px; }
  .ports-out { align-items: flex-end; }
  .port { display: flex; flex-direction: column; align-items: center; gap: 3px; cursor: crosshair; }
  .port.in  { align-items: flex-start; }
  .port.out { align-items: flex-end; }
  .port-dot {
    width: 14px; height: 14px; border-radius: 50%;
    border: 3px solid #00c853;
    background: #000;
    transition: all 0.15s; position: relative; z-index: 10; flex-shrink: 0;
    box-shadow: 0 0 0 1px #000, inset 0 0 4px rgba(0,0,0,0.9);
  }
  .port-dot::before {
    content: ''; position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%); width: 32px; height: 32px; border-radius: 50%;
  }
  .port-dot:hover, .port-dot.active { background: #00c85322; transform: scale(1.2); box-shadow: 0 0 8px #00c853, 0 0 0 1px #000; }
  .port-dot.in { border-color: #2979ff; }
  .port-dot.in:hover { background: #2979ff22; box-shadow: 0 0 8px #2979ff, 0 0 0 1px #000; }
  /* Output jack colors by module type */
  .node-source .port-dot.out { border-color: #00c853; }
  .node-effect .port-dot.out { border-color: #2979ff; }
  .node-mod    .port-dot.out { border-color: #ffab00; }
  .node-sink   .port-dot.out { border-color: #aa00ff; }
  .node-source .port-dot.out:hover { background: #00c85322; box-shadow: 0 0 8px #00c853, 0 0 0 1px #000; }
  .node-effect .port-dot.out:hover { background: #2979ff22; box-shadow: 0 0 8px #2979ff, 0 0 0 1px #000; }
  .node-mod    .port-dot.out:hover { background: #ffab0022; box-shadow: 0 0 8px #ffab00, 0 0 0 1px #000; }
  .node-sink   .port-dot.out:hover { background: #aa00ff22; box-shadow: 0 0 8px #aa00ff, 0 0 0 1px #000; }
  .port-dot.snap-target { background: #00c85333 !important; transform: scale(1.7) !important; box-shadow: 0 0 0 3px rgba(0,200,83,0.3), 0 0 14px rgba(0,200,83,0.6) !important; }
  .port-dot.in.snap-target { background: #2979ff33 !important; box-shadow: 0 0 0 3px rgba(41,121,255,0.3), 0 0 14px rgba(41,121,255,0.6) !important; }
  .port-label { font-size: 7px; color: #383838; text-transform: uppercase; letter-spacing: 0.5px; line-height: 1; }

  #info-bar {
    position: fixed; bottom: 0; left: 180px; right: 0; height: 26px;
    background: #060606; border-top: 1px solid #181818;
    display: flex; align-items: center; padding: 0 16px; gap: 24px;
    font-size: 9px; color: #2a2a2a; z-index: 50; letter-spacing: 1.5px; text-transform: uppercase;
  }
  #info-bar span { color: #383838; }
  #status-msg { margin-left: auto; color: #00c853; letter-spacing: 2px; }

  /* ‚îÄ‚îÄ Perf monitor ‚îÄ‚îÄ */
  #perf-panel {
    position: absolute; bottom: 0; left: 0; right: 0;
    padding: 10px 8px 12px; border-top: 1px solid #181818;
    background: #0a0a0a;
  }
  .perf-label { font-size: 7px; letter-spacing: 3px; text-transform: uppercase; color: #282828; margin-bottom: 6px; }
  .perf-row { display: flex; justify-content: space-between; font-size: 9px; color: #383838; margin-bottom: 4px; }
  .perf-val { color: #666; font-variant-numeric: tabular-nums; }
  #perf-canvas { display: block; width: 100%; height: 40px; border-radius: 1px; background: #060606; border: 1px solid #181818; margin-top: 6px; }

  /* ‚îÄ‚îÄ Sequencer ‚îÄ‚îÄ */
  .seq-grid { display: grid; gap: 3px; margin-top: 8px; }
  .seq-step {
    display: flex; flex-direction: column; align-items: center;
    background: #080808; border: 1px solid #1e1e1e; border-radius: 1px;
    padding: 4px 2px; cursor: pointer; transition: background 0.1s, border-color 0.1s;
  }
  .seq-step.active   { background: #071007; border-color: #00c85366; }
  .seq-step.playing  { background: #0a1a0a; border-color: #00c853; box-shadow: 0 0 8px rgba(0,200,83,0.4); }
  .seq-step.inactive { opacity: 0.25; }
  .seq-step-num { font-size: 7px; color: #2a2a2a; margin-bottom: 2px; }
  .seq-freq {
    background: none; border: none; color: #3a5a3a;
    font-family: 'Share Tech Mono', monospace; font-size: 9px; width: 100%; text-align: center;
    outline: none; padding: 1px 0; cursor: text;
  }
  .seq-step.active  .seq-freq { color: #00c85388; }
  .seq-step.playing .seq-freq { color: #00c853; font-weight: 600; }
  .seq-bpm-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
  .seq-note-label {
    font-size: 7px; color: #00c853; font-weight: 600; min-height: 10px; margin-top: 2px;
  }
/* ‚îÄ‚îÄ HP overlap highlight ‚îÄ‚îÄ */
.node.hp-overlap { outline: 2px solid rgba(255,50,50,0.5); background: linear-gradient(rgba(255,0,0,0.05), rgba(255,0,0,0.05)) !important; }

/* ‚îÄ‚îÄ Drum Machine ‚îÄ‚îÄ */
.dm-panel { padding: 0; width: 100%; }
.dm-controls { display:flex; align-items:center; gap:6px; padding:0 0 6px; border-bottom:1px solid #1e1e1e; margin-bottom:5px; flex-wrap:wrap; }
.dm-channel { display:flex; align-items:center; gap:0; margin-bottom:3px; height:22px; }
.dm-ch-label { font-size:6px; color:#555; text-transform:uppercase; letter-spacing:1px; width:46px; flex-shrink:0; text-align:right; padding-right:5px; line-height:22px; white-space:nowrap; }
.dm-steps { display:flex; gap:2px; flex:1; }
.dm-step { width:20px; height:20px; border-radius:1px; background:#0d0d0d; border:1px solid #1e1e1e; cursor:pointer; transition:background 0.05s,border-color 0.05s; flex-shrink:0; }
.dm-step.beat1 { border-left-color:#2d2d2d; }
.dm-step.grp2  { margin-left:3px; }
.dm-step.on    { background:#071507; border-color:#00c85355; }
.dm-step.playing { background:#00c853 !important; border-color:#00ff66 !important; box-shadow:0 0 6px rgba(0,200,83,0.8) !important; }
.dm-step:hover:not(.playing) { border-color:#444; background:#181818; }
.dm-led { width:7px; height:7px; border-radius:50%; background:#0d0d0d; border:1px solid #1e1e1e; flex-shrink:0; transition:background 0.04s,box-shadow 0.04s; margin-left:4px; }
.dm-led.active { background:var(--led-color,#00c853); box-shadow:0 0 5px var(--led-color,#00c853); }
.dm-btn { background:#0d0d0d; border:1px solid #2a2a2a; color:#555; padding:3px 10px; border-radius:2px; cursor:pointer; font-family:'Share Tech Mono',monospace; font-size:9px; text-transform:uppercase; letter-spacing:1px; transition:all 0.15s; }
.dm-btn:hover { background:#1a1a1a; border-color:#555; color:#aaa; }
.dm-btn.running { border-color:#00c853; color:#00c853; }
.dm-btn.running:hover { background:#00c85318; }
.dm-bpm { background:#060606; border:1px solid #1e1e1e; border-radius:1px; color:#ffab00; font-family:'Share Tech Mono',monospace; font-size:10px; padding:2px 5px; width:50px; text-align:right; outline:none; -moz-appearance:textfield; }
.dm-bpm::-webkit-outer-spin-button,.dm-bpm::-webkit-inner-spin-button{-webkit-appearance:none;}
.dm-label { font-size:7px; color:#444; text-transform:uppercase; letter-spacing:1px; flex-shrink:0; }
.dm-swing { background:#060606; border:1px solid #1e1e1e; border-radius:1px; color:#888; font-family:'Share Tech Mono',monospace; font-size:10px; padding:2px 4px; width:34px; text-align:right; outline:none; -moz-appearance:textfield; }
.dm-swing::-webkit-outer-spin-button,.dm-swing::-webkit-inner-spin-button{-webkit-appearance:none;}
.dm-vol-r { -webkit-appearance:none; appearance:none; width:28px; height:4px; border-radius:2px; background:#222; outline:none; cursor:pointer; flex-shrink:0; margin:0 3px; vertical-align:middle; }
.dm-vol-r::-webkit-slider-thumb { -webkit-appearance:none; width:8px; height:14px; background:#444; border-radius:2px; cursor:ns-resize; }
.dm-vol-r::-moz-range-thumb { width:8px; height:14px; background:#444; border-radius:2px; border:none; cursor:ns-resize; }

@keyframes node-land {
  0%   { transform: scale(1, 1);    box-shadow: none; }
  12%  { transform: scale(1.015, 0.97); }
  35%  { transform: scale(0.99, 1.01); }
  100% { transform: scale(1, 1); }
}
.node-land { animation: node-land 0.28s ease-out forwards; }
@keyframes node-delete {
  0%   { transform: scale(1);    opacity: 1; filter: brightness(1); }
  20%  { transform: scale(1.04); opacity: 1; filter: brightness(2) hue-rotate(40deg); }
  100% { transform: scale(0.8);  opacity: 0; filter: brightness(0.2); }
}
.node-delete { animation: node-delete 0.22s ease-in forwards; pointer-events: none; }

/* ‚îÄ‚îÄ Rotary knob system ‚îÄ‚îÄ */
.knob-wrap {
  display: inline-flex; flex-direction: column; align-items: center;
  gap: 3px; cursor: ns-resize; user-select: none;
}
.knob {
  width: 34px; height: 34px; border-radius: 50%;
  background: radial-gradient(circle at 35% 35%, #3a3a3a, #0d0d0d);
  border: 2px solid #3a3a3a;
  position: relative;
  box-shadow: 0 2px 6px rgba(0,0,0,0.8), inset 0 1px 0 rgba(255,255,255,0.06);
  transition: border-color 0.15s;
}
.knob:hover { border-color: #555; }
.knob::after {
  content: '';
  position: absolute;
  width: 2px; height: 11px;
  background: #fff;
  top: 4px; left: 50%;
  transform: translateX(-50%) rotate(var(--rot, -135deg));
  border-radius: 1px;
  transform-origin: bottom center;
  box-shadow: 0 0 3px rgba(255,255,255,0.4);
}
.knob-val {
  font-size: 8px; color: #555;
  font-family: 'Share Tech Mono', monospace;
  letter-spacing: 0.5px;
}

/* ‚îÄ‚îÄ Help / Share modals inherit correct font ‚îÄ‚îÄ */
#help-modal, #share-url-input {
  font-family: 'Share Tech Mono', monospace !important;
}
</style>
</head>
<body>

<div id="toolbar">
  <span class="logo">‚óà synth.html</span>
  <span style="font-size:9px;color:#484f58;letter-spacing:1px;margin-left:-10px">v0.7.0</span>
  <div class="tb-sep"></div>
  <button class="tb-btn play" id="play-btn" onclick="startAudio()">‚ñ∂ Play</button>
  <button class="tb-btn stop" id="stop-btn" onclick="stopAudio()">‚ñ† Stop</button>
  <div class="tb-sep"></div>
  <button class="tb-btn" onclick="clearAll()">Clear</button>
  <button class="tb-btn" onclick="autoArrange()">Auto Arrange</button>
  <select class="tb-select" id="preset-select" onchange="loadPreset(this.value); this.value=''">
    <option value="">Load preset‚Ä¶</option>
    <optgroup label="Built-in">
      <option value="drone">Drone</option>
      <option value="wobble">Wobble Bass</option>
      <option value="space">Space Echo</option>
      <option value="fuzz">Fuzz Lead</option>
      <option value="arpseq">Arp Sequencer</option>
      <option value="stereopan">Stereo Pan</option>
      <option value="pingpong">Ping-Pong Echo</option>
      <option value="keyjam">Keyboard Jam</option>
      <option value="envdemo">Envelope ADSR</option>
      <option value="drum_loop">Drum Loop</option>
    </optgroup>
    <optgroup label="Saved" id="user-preset-group"></optgroup>
  </select>
  <button class="tb-btn" id="btn-save"   onclick="savePreset()"        style="border-color:#c97bff;color:#c97bff">Save</button>
  <button class="tb-btn" id="btn-delete" onclick="deleteCurrentPreset()" style="border-color:#f85149;color:#f85149;opacity:0.4" disabled>Delete</button>
  <button class="tb-btn" onclick="shareLink()" style="border-color:#58d68d;color:#58d68d" title="Copy shareable link">‚¨° Share</button>
  <div style="margin-left:auto; display:flex; align-items:center; gap:8px;">
    <span style="font-size:10px; color:#484f58;">VOL</span>
    <input id="master-vol" type="range" min="0" max="1" step="0.01" value="0.04"
      style="width:80px; accent-color:#58d68d; cursor:pointer"
      oninput="setMasterVol(this.value)">
    <span style="font-size:10px; color:#484f58; width:30px" id="vol-pct">10%</span>
    <div class="tb-sep"></div>
    <button class="tb-btn" onclick="toggleHelp()" title="Help" style="border-color:#c97bff;color:#c97bff;font-size:13px;padding:4px 10px">?</button>
  </div>
</div>

<!-- Help Modal -->
<div id="help-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.75);z-index:1000;display:none;align-items:center;justify-content:center">
  <div id="help-modal" style="background:#0d0d0d;border:1px solid #222;border-radius:8px;max-width:560px;width:90%;max-height:80vh;overflow-y:auto;padding:32px;position:relative;font-size:12px;line-height:1.7">
    <button onclick="closeHelp()" style="position:absolute;top:14px;right:16px;background:none;border:none;color:#484f58;font-size:18px;cursor:pointer;line-height:1">‚úï</button>

    <div style="font-size:22px;font-weight:700;color:#c97bff;letter-spacing:1px;margin-bottom:4px">‚óà synth.html</div>
    <div style="color:#6e7681;font-size:11px;margin-bottom:20px;font-style:italic">a single HTML file that somehow makes music</div>

    <p style="color:#c9d1d9;margin-bottom:18px">
      A modular synthesizer that lives entirely in one <code style="background:#21262d;padding:1px 5px;border-radius:3px;color:#79c0ff">.html</code> file ‚Äî
      no server, no build step, no npm install, no existential dread.
      Drag nodes, patch cables, and sculpt sound like it's 1972 but your browser is the Moog.
    </p>

    <div style="color:#58d68d;font-size:10px;letter-spacing:2px;text-transform:uppercase;margin-bottom:10px">Getting Started</div>
    <div style="color:#c9d1d9;margin-bottom:18px">
      <div style="margin-bottom:6px">‚ë† Drag a node from the <strong style="color:#e0e0e0">left palette</strong> onto the canvas</div>
      <div style="margin-bottom:6px">‚ë° Connect nodes by dragging from an <strong style="color:#e0e0e0">output port</strong> (right side) to an <strong style="color:#e0e0e0">input port</strong> (left side)</div>
      <div style="margin-bottom:6px">‚ë¢ Grab a <strong style="color:#e0e0e0">wire mid-flight</strong> to rewire it</div>
      <div style="margin-bottom:6px">‚ë£ Hit <strong style="color:#58d68d">‚ñ∂ Play</strong> to start audio ‚Äî every patch needs a <strong style="color:#e0e0e0">Speaker</strong> node to make sound</div>
      <div>‚ë§ Not sure where to start? Load a <strong style="color:#e0e0e0">preset</strong> from the dropdown</div>
    </div>

    <div style="color:#58d68d;font-size:10px;letter-spacing:2px;text-transform:uppercase;margin-bottom:10px">Keyboard Shortcuts</div>
    <div style="display:grid;grid-template-columns:auto 1fr;gap:4px 16px;color:#c9d1d9;margin-bottom:18px">
      <span style="color:#c97bff;font-family:monospace">A S D F G H J K</span><span>white keys (C D E F G A B C)</span>
      <span style="color:#c97bff;font-family:monospace">W E T Y U</span><span>black keys (C# D# F# G# A#)</span>
      <span style="color:#c97bff;font-family:monospace">- / =</span><span>octave down / up</span>
      <span style="color:#c97bff;font-family:monospace">Delete</span><span>remove selected node</span>
      <span style="color:#c97bff;font-family:monospace">Ctrl + Scroll</span><span>zoom in/out (around cursor)</span>
      <span style="color:#c97bff;font-family:monospace">Space + Drag</span><span>pan canvas</span>
      <span style="color:#c97bff;font-family:monospace">Home / dbl-click</span><span>reset view</span>
    </div>

    <div style="color:#58d68d;font-size:10px;letter-spacing:2px;text-transform:uppercase;margin-bottom:10px">Tips</div>
    <div style="color:#c9d1d9;margin-bottom:8px">
      <div style="margin-bottom:5px">üîå <strong style="color:#e0e0e0">Port colors</strong> match node colors ‚Äî connect same-colored ports for cleaner patches</div>
      <div style="margin-bottom:5px">üéõÔ∏è <strong style="color:#e0e0e0">LFO ‚Üí freq_mod</strong> on any filter or oscillator gives you wobble and movement</div>
      <div style="margin-bottom:5px">üì° <strong style="color:#e0e0e0">‚¨° Share</strong> encodes your entire patch into the URL ‚Äî send it to someone</div>
      <div>üíæ <strong style="color:#e0e0e0">Save</strong> stores patches locally in your browser</div>
    </div>

    <div style="margin-top:20px;padding-top:16px;border-top:1px solid #21262d;color:#484f58;font-size:10px;text-align:center;line-height:2">
      made with ‚ô• and a single &lt;script&gt; tag ¬∑ no cookies ¬∑ no tracking ¬∑ just vibes<br>
      <a href="https://github.com/zpeters/synth-html" target="_blank"
        style="color:#5da0d0;text-decoration:none;letter-spacing:0.5px">‚¨° github.com/zpeters/synth-html</a>
    </div>
  </div>
</div>

<!-- Share Modal -->
<div id="share-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.7);z-index:1000;align-items:center;justify-content:center">
  <div style="background:#0d0d0d;border:1px solid #222;border-radius:8px;padding:24px 28px;width:520px;max-width:92vw;position:relative;font-family:'Share Tech Mono',monospace">
    <button onclick="closeShareModal()" style="position:absolute;top:12px;right:14px;background:none;border:none;color:#484f58;font-size:18px;cursor:pointer;line-height:1">‚úï</button>
    <div style="font-size:13px;font-weight:700;color:#58d68d;letter-spacing:1px;margin-bottom:4px">‚¨° Share Patch</div>
    <div id="share-patch-name" style="font-size:10px;color:#6e7681;margin-bottom:16px;font-style:italic"></div>
    <div style="display:flex;gap:8px;align-items:center">
      <input id="share-url-input" readonly
        style="flex:1;background:#0d1117;border:1px solid #30363d;border-radius:4px;color:#79c0ff;
               font-family:'Share Tech Mono',monospace;font-size:11px;padding:8px 10px;outline:none;
               cursor:text;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"
        onclick="this.select()"
        value="">
      <button id="share-copy-btn" onclick="copyShareUrl()"
        style="background:#21262d;border:1px solid #58d68d;color:#58d68d;
               font-family:'Share Tech Mono',monospace;font-size:11px;padding:8px 14px;
               border-radius:4px;cursor:pointer;white-space:nowrap;transition:all 0.15s"
        onmouseover="this.style.background='#58d68d22'"
        onmouseout="this.style.background='#21262d'">Copy</button>
    </div>
    <div style="font-size:9px;color:#484f58;margin-top:10px">Link encodes your entire patch ‚Äî anyone with it can load it instantly.</div>
  </div>
</div>

<div id="node-palette">
  <div class="palette-section">
    <div class="palette-label">Sources</div>
    <div class="palette-item pi-source" draggable="true" data-type="keyboard">
      <div class="item-name">Keyboard</div><div class="item-desc">Piano input</div>
    </div>
    <div class="palette-item pi-source" draggable="true" data-type="oscillator">
      <div class="item-name">Oscillator</div><div class="item-desc">Square/sine/saw/tri</div>
    </div>
    <div class="palette-item pi-source" draggable="true" data-type="noise">
      <div class="item-name">Noise</div><div class="item-desc">White noise</div>
    </div>
    <div class="palette-item pi-mod" draggable="true" data-type="sequencer">
      <div class="item-name">Sequencer</div><div class="item-desc">8-step note sequencer</div>
    </div>
    <div class="palette-item pi-source" draggable="true" data-type="drum_machine" style="border-left-color:#ff6d00">
      <div class="item-name">Drum Machine</div><div class="item-desc">16-step, 6 channels</div>
    </div>
  </div>
  <div class="palette-section">
    <div class="palette-label">Effects</div>
    <div class="palette-item pi-effect" draggable="true" data-type="gain">
      <div class="item-name">Gain</div><div class="item-desc">Volume / amplifier</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="filter">
      <div class="item-name">Filter</div><div class="item-desc">LP / HP / BP / notch</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="delay">
      <div class="item-name">Delay</div><div class="item-desc">Echo + feedback</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="ping_pong">
      <div class="item-name">Ping-Pong</div><div class="item-desc">Stereo bounce delay</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="reverb">
      <div class="item-name">Reverb</div><div class="item-desc">Convolution room</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="distortion">
      <div class="item-name">Distortion</div><div class="item-desc">Waveshaper drive</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="compressor">
      <div class="item-name">Compressor</div><div class="item-desc">Dynamics control</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="pan">
      <div class="item-name">Pan</div><div class="item-desc">Stereo position</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="mixer">
      <div class="item-name">Mixer</div><div class="item-desc">3-channel sum + gain</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="envelope">
      <div class="item-name">Envelope</div><div class="item-desc">ADSR amp shape</div>
    </div>
  </div>
  <div class="palette-section">
    <div class="palette-label">Modulators</div>
    <div class="palette-item pi-mod" draggable="true" data-type="lfo">
      <div class="item-name">LFO</div><div class="item-desc">Modulate anything</div>
    </div>
  </div>
  <div class="palette-section">
    <div class="palette-label">Output</div>
    <div class="palette-item pi-sink" draggable="true" data-type="speaker">
      <div class="item-name">Speaker</div><div class="item-desc">Audio out + VU</div>
    </div>
  </div>
  <div class="palette-section">
    <div class="palette-label">Visualization</div>
    <div class="palette-item pi-sink" draggable="true" data-type="oscilloscope">
      <div class="item-name">Oscilloscope</div><div class="item-desc">Waveform display</div>
    </div>
    <div class="palette-item pi-sink" draggable="true" data-type="spectrum">
      <div class="item-name">Spectrum</div><div class="item-desc">FFT frequency bars</div>
    </div>
    <div class="palette-item pi-sink" draggable="true" data-type="xy_scope">
      <div class="item-name">XY Scope</div><div class="item-desc">Lissajous (X+Y)</div>
    </div>
    <div class="palette-item pi-sink" draggable="true" data-type="stereo_scope">
      <div class="item-name">Stereo Scope</div><div class="item-desc">L+R waveforms</div>
    </div>
  </div>
  <div id="perf-panel">
    <div class="perf-label">Performance</div>
    <div class="perf-row"><span>FPS</span><span class="perf-val" id="perf-fps">--</span></div>
    <div class="perf-row" id="perf-heap-row" style="display:none"><span>Heap</span><span class="perf-val" id="perf-heap">--</span></div>
    <canvas id="perf-canvas" width="164" height="40"></canvas>
  </div>
</div>

<div id="canvas-area"><svg id="svg-layer"></svg></div>

<div id="info-bar">
  <span>nodes: <span id="stat-nodes">0</span></span>
  <span>edges: <span id="stat-edges">0</span></span>
  <span>zoom: <span id="stat-zoom">100%</span></span>
  <span id="status-msg"></span>
</div>

<script>
// ‚îÄ‚îÄ‚îÄ Node definitions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const NODE_DEFS = {
  oscillator: {
    label:'Oscillator', color:'#00c853', kind:'source', ins:['freq','freq_mod'], outs:['signal'],
    params:{ freq:220, wave:'square' },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Freq</span>
        <input class="param-input" type="number" min="20" max="20000" value="${p.freq}"
          onchange="updateParam('${id}','freq',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Wave</span>
        <select class="param-select" onchange="updateParam('${id}','wave',this.value)">
          ${['square','sine','sawtooth','triangle'].map(w=>`<option value="${w}"${p.wave===w?' selected':''}>${w}</option>`).join('')}
        </select>
      </div>`; }
  },
  noise: {
    label:'Noise', color:'#00c853', kind:'source', ins:[], outs:['signal'],
    params:{ level:0.5 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Level</span>
        <input class="param-input" type="number" min="0" max="1" step="0.05" value="${p.level}"
          onchange="updateParam('${id}','level',this.value)">
      </div>`; }
  },
  keyboard: {
    label:'Keyboard', color:'#00c853', kind:'source', ins:[], outs:['freq','gate'],
    minWidth: 220,
    params: { octave: 4 },
    renderBody(id, p) {
      return `
    <div class="param-row"><span class="param-label">Oct</span>
      <input class="param-input" type="number" min="1" max="7" value="${p.octave}"
        onchange="updateParam('${id}','octave',+this.value)">
    </div>
    <div class="kb-wrap" id="${id}-kb" style="position:relative;height:48px;margin-top:6px;user-select:none;">
      ${[0,2,4,5,7,9,11,12].map((semi,i) => `
        <div class="kb-white" data-id="${id}" data-semi="${semi}"
          style="position:absolute;left:${i*24}px;width:22px;height:48px;background:#e8e8e8;border:1px solid #333;border-radius:0 0 3px 3px;cursor:pointer;box-sizing:border-box"
          onmousedown="kbPress('${id}',${semi})" onmouseup="kbRelease('${id}',${semi})" onmouseleave="kbRelease('${id}',${semi})">
        </div>`).join('')}
      ${[[1,1],[3,2],[6,4],[8,5],[10,6]].map(([semi,wi]) => `
        <div class="kb-black" data-id="${id}" data-semi="${semi}"
          style="position:absolute;left:${wi*24-8}px;width:16px;height:30px;background:#222;border:1px solid #000;border-radius:0 0 2px 2px;z-index:1;cursor:pointer;box-sizing:border-box"
          onmousedown="kbPress('${id}',${semi})" onmouseup="kbRelease('${id}',${semi})" onmouseleave="kbRelease('${id}',${semi})">
        </div>`).join('')}
    </div>
    <div style="font-size:9px;color:#484f58;margin-top:4px">A-K = white keys ¬∑ W E T Y U = black</div>`;
    }
  },
  envelope: {
    label:'Envelope', color:'#2979ff', kind:'effect', ins:['signal','gate'], outs:['signal'],
    params:{ attack:0.01, decay:0.15, sustain:0.7, release:0.4 },
    renderBody(id,p){ return `
      <canvas id="${id}-env-cv" width="160" height="54"
        style="display:block;width:160px;height:54px;background:#0d1117;border-radius:4px;margin:2px 0 8px;border:1px solid #21262d"></canvas>
      <div class="param-row"><span class="param-label">Attack</span>
        <input class="param-input" type="number" min="0.001" max="4" step="0.01" value="${p.attack}"
          onchange="updateParam('${id}','attack',+this.value);drawEnvelope('${id}')">
      </div>
      <div class="param-row"><span class="param-label">Decay</span>
        <input class="param-input" type="number" min="0.001" max="4" step="0.01" value="${p.decay}"
          onchange="updateParam('${id}','decay',+this.value);drawEnvelope('${id}')">
      </div>
      <div class="param-row"><span class="param-label">Sustain</span>
        <input class="param-input" type="range" min="0" max="1" step="0.01" value="${p.sustain}"
          style="width:76px" oninput="updateParam('${id}','sustain',+this.value);document.getElementById('${id}-susval').textContent=(+this.value*100|0)+'%';drawEnvelope('${id}')">
        <span id="${id}-susval" style="color:#6e7681;width:30px;text-align:right">${(p.sustain*100|0)}%</span>
      </div>
      <div class="param-row"><span class="param-label">Release</span>
        <input class="param-input" type="number" min="0.001" max="8" step="0.01" value="${p.release}"
          onchange="updateParam('${id}','release',+this.value);drawEnvelope('${id}')">
      </div>`; }
  },
  gain: {
    label:'Gain', color:'#2979ff', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ gain:0.5 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Gain</span>
        <input class="param-input" type="number" min="0" max="2" step="0.05" value="${p.gain}"
          onchange="updateParam('${id}','gain',this.value)">
      </div>`; }
  },
  pan: {
    label:'Pan', color:'#2979ff', kind:'effect', ins:['signal','pan_mod'], outs:['signal'],
    params:{ pan:0 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Pan</span>
        <input class="param-input" type="range" min="-1" max="1" step="0.01" value="${p.pan}"
          style="width:100px" oninput="updateParam('${id}','pan',+this.value);document.getElementById('${id}-panval').textContent=Math.round(+this.value*100)">
        <span id="${id}-panval" style="color:#6e7681;width:30px;text-align:right">${Math.round(p.pan*100)}</span>
      </div>`; }
  },
  filter: {
    label:'Filter', color:'#2979ff', kind:'effect', ins:['signal','freq_mod'], outs:['signal'],
    params:{ type:'lowpass', freq:800, q:1 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Type</span>
        <select class="param-select" onchange="updateParam('${id}','type',this.value)">
          ${['lowpass','highpass','bandpass','notch'].map(t=>`<option value="${t}"${p.type===t?' selected':''}>${t}</option>`).join('')}
        </select>
      </div>
      <div class="param-row"><span class="param-label">Freq</span>
        <input class="param-input" type="number" min="20" max="20000" value="${p.freq}"
          onchange="updateParam('${id}','freq',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Q</span>
        <input class="param-input" type="number" min="0.1" max="30" step="0.1" value="${p.q}"
          onchange="updateParam('${id}','q',this.value)">
      </div>`; }
  },
  delay: {
    label:'Delay', color:'#2979ff', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ time:0.3, feedback:0.4 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Time (s)</span>
        <input class="param-input" type="number" min="0" max="5" step="0.05" value="${p.time}"
          onchange="updateParam('${id}','time',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Feedback</span>
        <input class="param-input" type="number" min="0" max="0.95" step="0.05" value="${p.feedback}"
          onchange="updateParam('${id}','feedback',this.value)">
      </div>`; }
  },
  ping_pong: {
    label:'Ping-Pong', color:'#2979ff', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ timeL:0.3, timeR:0.45, feedback:0.4, wet:0.5 },
    renderBody(id,p){ return `
    <div class="param-row"><span class="param-label">Time L</span>
      <input class="param-input" type="number" min="0.01" max="2" step="0.01" value="${p.timeL}"
        onchange="updateParam('${id}','timeL',+this.value)"></div>
    <div class="param-row"><span class="param-label">Time R</span>
      <input class="param-input" type="number" min="0.01" max="2" step="0.01" value="${p.timeR}"
        onchange="updateParam('${id}','timeR',+this.value)"></div>
    <div class="param-row"><span class="param-label">Feedback</span>
      <input class="param-input" type="number" min="0" max="0.95" step="0.01" value="${p.feedback}"
        onchange="updateParam('${id}','feedback',+this.value)"></div>
    <div class="param-row"><span class="param-label">Wet</span>
      <input class="param-input" type="number" min="0" max="1" step="0.05" value="${p.wet}"
        onchange="updateParam('${id}','wet',+this.value)"></div>`; }
  },
  reverb: {
    label:'Reverb', color:'#2979ff', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ duration:2, decay:2, wet:0.5 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Duration</span>
        <input class="param-input" type="number" min="0.1" max="10" step="0.1" value="${p.duration}"
          onchange="updateParam('${id}','duration',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Decay</span>
        <input class="param-input" type="number" min="0.1" max="10" step="0.1" value="${p.decay}"
          onchange="updateParam('${id}','decay',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Wet</span>
        <input class="param-input" type="number" min="0" max="1" step="0.05" value="${p.wet}"
          onchange="updateParam('${id}','wet',this.value)">
      </div>`; }
  },
  distortion: {
    label:'Distortion', color:'#2979ff', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ amount:50 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Amount</span>
        <input class="param-input" type="number" min="0" max="400" step="10" value="${p.amount}"
          onchange="updateParam('${id}','amount',this.value)">
      </div>`; }
  },
  compressor: {
    label:'Compressor', color:'#2979ff', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ threshold:-24, ratio:4, knee:10 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Threshold</span>
        <input class="param-input" type="number" min="-100" max="0" value="${p.threshold}"
          onchange="updateParam('${id}','threshold',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Ratio</span>
        <input class="param-input" type="number" min="1" max="20" step="0.5" value="${p.ratio}"
          onchange="updateParam('${id}','ratio',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Knee</span>
        <input class="param-input" type="number" min="0" max="40" value="${p.knee}"
          onchange="updateParam('${id}','knee',this.value)">
      </div>`; }
  },
  lfo: {
    label:'LFO', color:'#ffab00', kind:'mod', ins:[], outs:['mod'],
    params:{ freq:2, depth:100 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Rate (Hz)</span>
        <input class="param-input" type="number" min="0.01" max="30" step="0.1" value="${p.freq}"
          onchange="updateParam('${id}','freq',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Depth</span>
        <input class="param-input" type="number" min="0" max="5000" step="10" value="${p.depth}"
          onchange="updateParam('${id}','depth',this.value)">
      </div>`; }
  },
  speaker: {
    label:'Speaker', color:'#aa00ff', kind:'sink', ins:['signal'], outs:[],
    params:{},
    renderBody(id,p){ return `<div class="vu-bar"><div class="vu-fill" id="${id}-vu"></div></div>`; }
  },
  oscilloscope: {
    label:'Oscilloscope', color:'#aa00ff', kind:'sink', ins:['signal'], outs:[],
    params:{ zoom:1, mode:'standard' },
    renderBody(id,p){ return `
      <canvas class="scope-canvas" id="${id}-scope" width="158" height="80"></canvas>
      <div class="param-row" style="margin-top:4px"><span class="param-label">Zoom</span>
        <input class="param-input" type="number" min="0.1" max="10" step="0.1" value="${p.zoom}"
          onchange="updateParam('${id}','zoom',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Mode</span>
        <select class="param-select" onchange="updateParam('${id}','mode',this.value)">
          ${['standard','trippy','phosphor'].map(m=>`<option value="${m}"${(p.mode||'standard')===m?' selected':''}>${m}</option>`).join('')}
        </select>
      </div>`; }
  },

  spectrum: {
    label:'Spectrum', color:'#aa00ff', kind:'sink', ins:['signal'], outs:[],
    params:{ mode:'standard' },
    renderBody(id,p){ return `
      <canvas class="scope-canvas" id="${id}-scope" width="158" height="80"></canvas>
      <div class="param-row" style="margin-top:4px"><span class="param-label">Mode</span>
        <select class="param-select" onchange="updateParam('${id}','mode',this.value)">
          ${['standard','trippy','phosphor'].map(m=>`<option value="${m}"${(p.mode||'standard')===m?' selected':''}>${m}</option>`).join('')}
        </select>
      </div>`; }
  },

  xy_scope: {
    label:'XY Scope', color:'#aa00ff', kind:'sink', ins:['x','y'], outs:[],
    params:{ mode:'standard' },
    renderBody(id,p){ return `
      <canvas class="scope-canvas" id="${id}-scope" width="158" height="80"></canvas>
      <div class="param-row" style="margin-top:4px"><span class="param-label">Mode</span>
        <select class="param-select" onchange="updateParam('${id}','mode',this.value)">
          ${['standard','trippy','phosphor'].map(m=>`<option value="${m}"${(p.mode||'standard')===m?' selected':''}>${m}</option>`).join('')}
        </select>
      </div>`; }
  },

  stereo_scope: {
    label:'Stereo Scope', color:'#aa00ff', kind:'sink', ins:['L','R'], outs:[],
    params:{ mode:'standard' },
    renderBody(id,p){ return `
      <canvas class="scope-canvas" id="${id}-scope" width="158" height="80"></canvas>
      <div class="param-row" style="margin-top:4px"><span class="param-label">Mode</span>
        <select class="param-select" onchange="updateParam('${id}','mode',this.value)">
          ${['standard','trippy','phosphor'].map(m=>`<option value="${m}"${(p.mode||'standard')===m?' selected':''}>${m}</option>`).join('')}
        </select>
      </div>`; }
  },

  mixer: {
    label:'Mixer', color:'#2979ff', kind:'effect',
    ins:['ch1','ch2','ch3'], outs:['signal'],
    params:{ gain1:0.8, gain2:0.8, gain3:0.8 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Ch 1</span>
        <input class="param-input" type="number" min="0" max="2" step="0.05" value="${p.gain1}"
          onchange="updateParam('${id}','gain1',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Ch 2</span>
        <input class="param-input" type="number" min="0" max="2" step="0.05" value="${p.gain2}"
          onchange="updateParam('${id}','gain2',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Ch 3</span>
        <input class="param-input" type="number" min="0" max="2" step="0.05" value="${p.gain3}"
          onchange="updateParam('${id}','gain3',this.value)">
      </div>`; }
  },

  sequencer: {
    label:'Sequencer', color:'#ffab00', kind:'mod',
    minWidth: 290,
    ins:[], outs:['freq'],
    params:{
      bpm: 120,
      notes: [220, 294, 330, 392, 440, 392, 330, 294],
      active:[1,   1,   1,   1,   1,   0,   1,   0  ]
    },
    renderBody(id,p){
      const notes  = p.notes;
      const active = p.active;
      let steps = `
      <div class="seq-bpm-row">
        <span class="param-label">BPM</span>
        <input class="param-input" type="number" min="30" max="300" value="${p.bpm}" style="width:70px"
          onchange="updateParam('${id}','bpm',+this.value)">
      </div>
      <div class="seq-grid" id="${id}-grid" style="grid-template-columns:repeat(8,1fr)">`;
      for (let i = 0; i < 8; i++) {
        const cls = active[i] ? 'active' : 'inactive';
        steps += `
        <div class="seq-step ${cls}" id="${id}-s${i}" onclick="toggleStep('${id}',${i})">
          <span class="seq-step-num">${i+1}</span>
          <input class="seq-freq" type="number" value="${notes[i]}"
            onclick="event.stopPropagation()"
            onchange="updateStepFreq('${id}',${i},+this.value)">
        </div>`;
      }
      steps += `</div>`;
      return steps;
    }
  },

  drum_machine: {
    label: 'Drum Machine', color: '#ff6d00', kind: 'source',
    ins: [], outs: ['mix_out'],
    params: {
      bpm: 120, swing: 0,
      kick_steps:    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], kick_vol:    0.9,
      snare_steps:   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], snare_vol:   0.8,
      clap_steps:    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], clap_vol:    0.7,
      hihat_steps:   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], hihat_vol:   0.7,
      openhat_steps: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], openhat_vol: 0.6,
      perc_steps:    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], perc_vol:    0.6,
    },
    renderBody(id, p) {
      const CHS = [
        { key:'kick',    label:'KICK',     color:'#ff4444' },
        { key:'snare',   label:'SNARE',    color:'#ffab00' },
        { key:'clap',    label:'CLAP',     color:'#ff8800' },
        { key:'hihat',   label:'HI-HAT',   color:'#00e5ff' },
        { key:'openhat', label:'OPEN HAT', color:'#69f0ae' },
        { key:'perc',    label:'PERC',     color:'#e040fb' },
      ];
      let h = `<div class="dm-panel">`;
      h += `<div class="dm-controls">
        <button class="dm-btn" id="${id}-dm-btn" onclick="dmToggle('${id}')">‚ñ∂ PLAY</button>
        <span class="dm-label">BPM</span>
        <input class="dm-bpm" type="number" min="30" max="300" value="${p.bpm}"
          onchange="updateParam('${id}','bpm',+this.value);dmUpdateBpm('${id}')">
        <span class="dm-label">SWING</span>
        <input class="dm-swing" type="number" min="0" max="50" value="${p.swing}"
          onchange="updateParam('${id}','swing',+this.value)">
        <span class="dm-label">%</span>
      </div>`;
      CHS.forEach(ch => {
        const steps = p[`${ch.key}_steps`];
        const vol   = p[`${ch.key}_vol`];
        h += `<div class="dm-channel">
          <span class="dm-ch-label">${ch.label}</span>
          <div class="dm-steps">`;
        for (let i = 0; i < 16; i++) {
          const on  = steps[i] ? ' on' : '';
          const b1  = i % 4 === 0 ? ' beat1' : '';
          const grp = i === 8 ? ' grp2' : '';
          h += `<div class="dm-step${on}${b1}${grp}" id="${id}-step-${ch.key}-${i}"
              onclick="dmToggleStep('${id}','${ch.key}',${i})"></div>`;
        }
        h += `</div>
          <input class="dm-vol-r" type="range" min="0" max="1" step="0.01" value="${vol}"
            title="${ch.label} vol" oninput="dmSetVol('${id}','${ch.key}',+this.value)">
          <div class="dm-led" id="${id}-led-${ch.key}" style="--led-color:${ch.color}"></div>
        </div>`;
      });
      h += `</div>`;
      return h;
    }
  },
};

// ‚îÄ‚îÄ‚îÄ Version ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const VERSION = '0.7.0';

// ‚îÄ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let nodes={}, edges=[], nodeIdCounter=0;
let dragging=null, dragOffset={x:0,y:0};
let connecting=null, previewPath=null, selectedNode=null;
let edgeEls=[]; // [{pathEl, hitEl, edge}] ‚Äî for wire animation
let wireRafId=null;
const edgeSprings={}; // edgeKey‚Üí{y,vy} spring offset per wire
function edgeSpringKey(e){return`${e.srcNode}:${e.srcPort}‚Üí${e.dstNode}:${e.dstPort}`;}
function getEdgeSpring(edge){
  const k=edgeSpringKey(edge);
  if(!edgeSprings[k]) edgeSprings[k]={y:0,vy:0};
  return edgeSprings[k];
}
let audioCtx=null, audioNodes={}, masterGain=null;
let rafId=null;
let seqState={};
let dmState={};  // drum machine scheduler state
let canvasScale=1.0;
let canvasOffset={x:0,y:0}; // pan offset in canvas space
let isPanning=false, panStart={x:0,y:0}, panStartOffset={x:0,y:0};
const ZOOM_MIN=0.15, ZOOM_MAX=4.0;
const GRID=24;
function snap(v){return Math.round(v/GRID)*GRID;}
// ‚îÄ‚îÄ‚îÄ HP (Horizontal Pitch) grid ‚Äî 1HP = 16px, rack row = 84HP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const HP = 16;
const RACK_HP = 84;      // 84HP = 1344px per rack row
const HP_WIDTHS = {      // module widths in HP units
  oscillator:8, filter:8, gain:4, envelope:12, sequencer:16,
  drum_machine:32, speaker:8, delay:10, reverb:10, distortion:10,
  compressor:10, lfo:6, noise:6, mixer:10, keyboard:16, pan:4,
  oscilloscope:10, spectrum:10, xy_scope:10, stereo_scope:10, ping_pong:10,
};
function snapHP(v){ return Math.round(v/HP)*HP; }
let scopeHistory={}; // { [nodeId]: Uint8Array[] } ‚Äî ring buffer for trippy echo
let activeKbNode = null; // id of focused keyboard node

const canvasEl = document.getElementById('canvas-area');
const svgLayer = document.getElementById('svg-layer');

// ‚îÄ‚îÄ‚îÄ Knob helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function mapToRot(val, min, max) {
  const pct = (max === min) ? 0 : Math.max(0, Math.min(1, (val - min) / (max - min)));
  return -135 + pct * 270;
}
function formatKnobVal(v) {
  const n = +v;
  if (Math.abs(n) >= 1000) return (n/1000).toFixed(1)+'k';
  if (Math.abs(n) >= 100)  return Math.round(n)+'';
  if (Math.abs(n) >= 10)   return n.toFixed(1);
  if (Math.abs(n) >= 1)    return n.toFixed(2);
  return n.toFixed(3);
}
function initNodeKnobs(nodeEl) {
  nodeEl.querySelectorAll('.param-input[type="number"]').forEach(input => {
    const min  = input.min  !== '' ? +input.min  : 0;
    const max  = input.max  !== '' ? +input.max  : 1;
    const step = input.step !== '' ? +input.step : 0.01;
    const val  = +input.value;

    const wrap = document.createElement('div');
    wrap.className = 'knob-wrap';

    const knobEl = document.createElement('div');
    knobEl.className = 'knob';
    knobEl.style.setProperty('--rot', mapToRot(val, min, max) + 'deg');

    const kvEl = document.createElement('div');
    kvEl.className = 'knob-val';
    kvEl.textContent = formatKnobVal(val);

    wrap.appendChild(knobEl);
    wrap.appendChild(kvEl);

    // Insert knob-wrap right before the input, then hide the input
    input.parentNode.insertBefore(wrap, input);
    input.style.display = 'none';

    // Drag: up = increase, down = decrease
    wrap.addEventListener('mousedown', e => {
      e.preventDefault(); e.stopPropagation();
      const startY   = e.clientY;
      const startVal = +input.value;
      const range    = max - min;

      const onMove = e2 => {
        const dy = startY - e2.clientY;
        let nv = Math.max(min, Math.min(max, startVal + (dy / 140) * range));
        if (step) nv = Math.round(nv / step) * step;
        nv = parseFloat(nv.toFixed(8));
        input.value = nv;
        knobEl.style.setProperty('--rot', mapToRot(nv, min, max) + 'deg');
        kvEl.textContent = formatKnobVal(nv);
        input.dispatchEvent(new Event('change'));
      };
      const onUp = () => {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
      };
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  });
}

// ‚îÄ‚îÄ‚îÄ Create node ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function createNode(type, x, y, overrideParams={}) {
  const def = NODE_DEFS[type];
  if (!def) return;
  x=snap(x); y=snap(y);
  const id = 'n'+(++nodeIdCounter);
  // Deep-copy params so array values (e.g. sequencer notes/active) aren't shared
  const params = {};
  for (const [k,v] of Object.entries(def.params)) params[k] = Array.isArray(v) ? [...v] : v;
  Object.assign(params, overrideParams);
  nodes[id] = { id, type, def, x, y, params };

  const el = document.createElement('div');
  el.className = 'node node-'+def.kind; el.id = id;
  el.style.left = x+'px'; el.style.top = y+'px';
  if (def.minWidth) el.style.minWidth = def.minWidth+'px';
  // Apply HP-based fixed width
  const hpW = (HP_WIDTHS[type] || 8) * HP;
  el.style.width    = hpW + 'px';
  el.style.minWidth = hpW + 'px';

  const inPorts  = def.ins.map(p=>`
    <div class="port in" data-node="${id}" data-port="${p}" data-dir="in">
      <div class="port-dot in" data-node="${id}" data-port="${p}" data-dir="in"></div>
      <span class="port-label">${p}</span>
    </div>`).join('');
  const outPorts = def.outs.map(p=>`
    <div class="port out" data-node="${id}" data-port="${p}" data-dir="out">
      <div class="port-dot out" data-node="${id}" data-port="${p}" data-dir="out"></div>
      <span class="port-label">${p}</span>
    </div>`).join('');

  el.innerHTML = `
    <div class="rack-handle" data-node="${id}"></div>
    <div class="node-header" data-node="${id}">
      <div class="node-color-dot" style="background:${def.color}"></div>
      <span class="node-title">${def.label}</span>
      <button class="delete-btn" onclick="deleteNode('${id}')">√ó</button>
    </div>
    <div class="node-body">${def.renderBody(id,params)}</div>
    <div class="node-ports">
      <div class="ports-in">${inPorts}</div>
      <div class="ports-out">${outPorts}</div>
    </div>
    <div class="rack-handle bottom" data-node="${id}"></div>`;

  canvasEl.appendChild(el);
  el.querySelectorAll('.node-header, .rack-handle').forEach(h => h.addEventListener('mousedown', onHeaderMousedown));
  el.querySelectorAll('.port-dot').forEach(d => d.addEventListener('mousedown', onPortMousedown));
  initNodeKnobs(el);
  if (type === 'envelope') requestAnimationFrame(() => drawEnvelope(id));
  updateStats();
  return id;
}

function updateParam(id, key, val) {
  if (!nodes[id]) return;
  nodes[id].params[key] = val;
  if (!audioCtx || !audioNodes[id]) return;
  const an = audioNodes[id];
  const t = audioCtx.currentTime;
  try {
    const n = nodes[id];
    if (n.type==='oscillator') {
      if (key==='freq') an.main.frequency.setTargetAtTime(+val,t,0.01);
      if (key==='wave') an.main.type = val;
    } else if (n.type==='noise') {
      if (key==='level') an.gainNode.gain.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='pan') {
      if (key==='pan') an.main.pan.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='gain') {
      if (key==='gain') an.main.gain.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='filter') {
      if (key==='type') an.main.type=val;
      if (key==='freq') an.main.frequency.setTargetAtTime(+val,t,0.01);
      if (key==='q') an.main.Q.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='delay') {
      if (key==='time') an.main.delayTime.setTargetAtTime(+val,t,0.01);
      if (key==='feedback') an.feedback.gain.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='ping_pong') {
      if (key==='timeL') an.delayL.delayTime.setTargetAtTime(+val,t,0.01);
      if (key==='timeR') an.delayR.delayTime.setTargetAtTime(+val,t,0.01);
      if (key==='feedback') { an.fbL.gain.setTargetAtTime(+val,t,0.01); an.fbR.gain.setTargetAtTime(+val,t,0.01); }
      if (key==='wet') { an.wet.gain.setTargetAtTime(+val,t,0.01); an.dry.gain.setTargetAtTime(1-+val,t,0.01); }
    } else if (n.type==='compressor') {
      if (key==='threshold') an.main.threshold.setTargetAtTime(+val,t,0.01);
      if (key==='ratio') an.main.ratio.setTargetAtTime(+val,t,0.01);
      if (key==='knee') an.main.knee.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='lfo') {
      if (key==='freq') an.osc.frequency.setTargetAtTime(+val,t,0.01);
      if (key==='depth') an.depth.gain.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='mixer') {
      if (key==='gain1') an.ch1.gain.setTargetAtTime(+val,t,0.01);
      if (key==='gain2') an.ch2.gain.setTargetAtTime(+val,t,0.01);
      if (key==='gain3') an.ch3.gain.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='sequencer') {
      if (key==='bpm' && seqState[id]) {
        clearInterval(seqState[id].intervalId);
        const tick=()=>{
          if(!audioCtx||!nodes[id]) return;
          const p=nodes[id].params, step=seqState[id].step;
          for(let i=0;i<8;i++) document.getElementById(`${id}-s${i}`)?.classList.remove('playing');
          if(p.active[step]){
            const freq=p.notes[step];
            edges.filter(e=>e.srcNode===id).forEach(e=>{
              const an=audioNodes[e.dstNode];
              if(an?.main?.frequency) an.main.frequency.setValueAtTime(freq, audioCtx.currentTime);
            });
          }
          document.getElementById(`${id}-s${seqState[id].step}`)?.classList.add('playing');
          seqState[id].step=(step+1)%8;
        };
        seqState[id].intervalId=setInterval(tick, 60000/+val);
      }
    }
  } catch(e) {}
}

// ‚îÄ‚îÄ‚îÄ Keyboard node helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function noteFreq(semi, octave) {
  const midiNote = (octave + 1) * 12 + semi;
  return 440 * Math.pow(2, (midiNote - 69) / 12);
}

function kbPress(nodeId, semi) {
  if (!audioCtx) return;
  const octave = +nodes[nodeId]?.params?.octave || 4;
  const freq = noteFreq(semi, octave);
  document.querySelectorAll(`#${nodeId}-kb [data-semi="${semi}"]`).forEach(el => {
    el.style.background = el.classList.contains('kb-black') ? '#5da0d0' : '#b3d4ff';
  });
  edges.filter(e => e.srcNode === nodeId).forEach(e => {
    if (e.srcPort === 'gate') {
      // Gate: trigger envelope attack on the connected node
      if (nodes[e.dstNode]?.type === 'envelope') envAttack(e.dstNode);
      return;
    }
    const an = audioNodes[e.dstNode];
    if (an?.main?.frequency) an.main.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.005);
    if (nodes[e.dstNode]?.params?.freq !== undefined) nodes[e.dstNode].params.freq = freq;
  });
  activeKbNode = nodeId;
}

function kbRelease(nodeId, semi) {
  document.querySelectorAll(`#${nodeId}-kb [data-semi="${semi}"]`).forEach(el => {
    el.style.background = el.classList.contains('kb-black') ? '#222' : '#e8e8e8';
  });
  // Trigger release on any connected envelope
  edges.filter(e => e.srcNode === nodeId && e.srcPort === 'gate').forEach(e => {
    if (nodes[e.dstNode]?.type === 'envelope') envRelease(e.dstNode);
  });
}

// ‚îÄ‚îÄ‚îÄ Envelope ADSR helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawEnvelope(id) {
  const cv = document.getElementById(id + '-env-cv');
  if (!cv) return;
  const p = nodes[id]?.params;
  if (!p) return;
  const W = cv.width, H = cv.height;
  const ctx = cv.getContext('2d');
  ctx.clearRect(0, 0, W, H);

  const a = Math.max(0.001, +p.attack);
  const d = Math.max(0.001, +p.decay);
  const s = Math.min(1, Math.max(0, +p.sustain));
  const r = Math.max(0.001, +p.release);

  // Allocate horizontal space proportionally; sustain gets 25% fixed
  const susHold = (a + d + r) * 0.4;
  const total = a + d + susHold + r;
  const px = t => 4 + (t / total) * (W - 8);
  const py = v => 4 + (1 - v) * (H - 12);  // leave 8px bottom for labels

  const x0 = px(0),         y0 = py(0);
  const x1 = px(a),         y1 = py(1);          // attack peak
  const x2 = px(a + d),     y2 = py(s);          // decay ‚Üí sustain
  const x3 = px(a + d + susHold), y3 = py(s);    // sustain end
  const x4 = px(total),     y4 = py(0);          // release end

  // Filled area
  const grad = ctx.createLinearGradient(0, 4, 0, H - 8);
  grad.addColorStop(0,   'rgba(214,160,88,0.35)');
  grad.addColorStop(1,   'rgba(214,160,88,0.03)');
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.lineTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.lineTo(x3, y3);
  ctx.lineTo(x4, y4);
  ctx.lineTo(x4, py(0));
  ctx.closePath();
  ctx.fillStyle = grad;
  ctx.fill();

  // Envelope line
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.lineTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.lineTo(x3, y3);
  ctx.lineTo(x4, y4);
  ctx.strokeStyle = '#d6a058';
  ctx.lineWidth = 1.8;
  ctx.lineJoin = 'round';
  ctx.stroke();

  // Dots at key points
  [[x1,y1],[x2,y2],[x3,y3]].forEach(([cx2,cy2]) => {
    ctx.beginPath();
    ctx.arc(cx2, cy2, 2.5, 0, Math.PI*2);
    ctx.fillStyle = '#d6a058';
    ctx.fill();
  });

  // Section labels
  ctx.font = '8px Share Tech Mono, monospace';
  ctx.fillStyle = '#484f58';
  const lY = H - 1;
  ctx.fillText('A', (x0 + x1) / 2 - 3, lY);
  ctx.fillText('D', (x1 + x2) / 2 - 3, lY);
  ctx.fillText('S', (x2 + x3) / 2 - 3, lY);
  ctx.fillText('R', (x3 + x4) / 2 - 3, lY);

  // Sustain level line (dashed)
  if (s > 0.01 && s < 0.99) {
    ctx.setLineDash([2, 3]);
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(W - 2, y2);
    ctx.strokeStyle = 'rgba(214,160,88,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.setLineDash([]);
  }
}

function envAttack(nodeId) {
  if (!audioCtx || !audioNodes[nodeId]) return;
  const g = audioNodes[nodeId].main.gain;
  const p = nodes[nodeId]?.params;
  if (!p) return;
  const t = audioCtx.currentTime;
  g.cancelScheduledValues(t);
  g.setValueAtTime(g.value, t);
  g.linearRampToValueAtTime(1.0, t + +p.attack);
  g.linearRampToValueAtTime(+p.sustain, t + +p.attack + +p.decay);
}
function envRelease(nodeId) {
  if (!audioCtx || !audioNodes[nodeId]) return;
  const g = audioNodes[nodeId].main.gain;
  const p = nodes[nodeId]?.params;
  if (!p) return;
  const t = audioCtx.currentTime;
  g.cancelScheduledValues(t);
  g.setValueAtTime(g.value, t);
  g.linearRampToValueAtTime(0, t + +p.release);
}

// ‚îÄ‚îÄ‚îÄ Sequencer helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function toggleStep(id, i) {
  if (!nodes[id]) return;
  const p = nodes[id].params;
  p.active[i] = p.active[i] ? 0 : 1;
  const el = document.getElementById(`${id}-s${i}`);
  if (el) {
    el.classList.toggle('active',   !!p.active[i]);
    el.classList.toggle('inactive', !p.active[i]);
  }
}
function updateStepFreq(id, i, val) {
  if (!nodes[id]) return;
  nodes[id].params.notes[i] = val;
}

// ‚îÄ‚îÄ‚îÄ Drum Machine helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const DM_CHS = ['kick','snare','clap','hihat','openhat','perc'];

function dmToggleStep(id, ch, step) {
  if (!nodes[id]) return;
  const steps = nodes[id].params[`${ch}_steps`];
  steps[step] = steps[step] ? 0 : 1;
  document.getElementById(`${id}-step-${ch}-${step}`)?.classList.toggle('on', !!steps[step]);
}
function dmSetVol(id, ch, val) {
  if (!nodes[id]) return;
  nodes[id].params[`${ch}_vol`] = val;
}
function dmUpdateBpm(id) {
  if (!dmState[id]?.intervalId) return;
  dmStop(id); dmStart(id);
}
function dmToggle(id) {
  if (!audioCtx) { alert('Press ‚ñ∂ Play first to start the audio engine.'); return; }
  if (dmState[id]?.intervalId) dmStop(id); else dmStart(id);
}
function dmStart(id) {
  if (!audioCtx || !nodes[id] || !audioNodes[id]) return;
  if (dmState[id]?.intervalId) return; // already running
  nodes[id].params.playing = true;
  const btn = document.getElementById(`${id}-dm-btn`);
  if (btn) { btn.textContent = '‚ñ† STOP'; btn.classList.add('running'); }
  dmState[id] = { currentStep: 0, nextNoteTime: audioCtx.currentTime + 0.05 };
  const AHEAD = 0.1; // 100ms lookahead
  function scheduler() {
    if (!audioCtx || !nodes[id] || !audioNodes[id]) return;
    const p = nodes[id].params;
    const spb = 60 / p.bpm;      // seconds per beat
    const sps = spb / 4;          // seconds per 16th-note step
    const out = audioNodes[id].output;
    while (dmState[id].nextNoteTime < audioCtx.currentTime + AHEAD) {
      const step = dmState[id].currentStep;
      const t    = dmState[id].nextNoteTime;
      const swingOffset = (step % 2 === 1) ? (p.swing / 100) * sps * 0.67 : 0;
      const st = t + swingOffset;
      DM_CHS.forEach(ch => {
        if (p[`${ch}_steps`][step]) {
          const vol = p[`${ch}_vol`] ?? 0.7;
          switch(ch) {
            case 'kick':    dmSynthKick(audioCtx, out, st, vol); break;
            case 'snare':   dmSynthSnare(audioCtx, out, st, vol); break;
            case 'clap':    dmSynthClap(audioCtx, out, st, vol); break;
            case 'hihat':   dmSynthHihat(audioCtx, out, st, vol); break;
            case 'openhat': dmSynthOpenhat(audioCtx, out, st, vol); break;
            case 'perc':    dmSynthPerc(audioCtx, out, st, vol); break;
          }
          // Schedule LED pulse
          const ledMs = Math.max(0, (st - audioCtx.currentTime) * 1000);
          setTimeout(() => {
            const led = document.getElementById(`${id}-led-${ch}`);
            if (led) { led.classList.add('active'); setTimeout(()=>led.classList.remove('active'), 80); }
          }, ledMs);
        }
      });
      // Schedule step highlight
      const hlMs = Math.max(0, (t - audioCtx.currentTime) * 1000);
      const stepCopy = step;
      setTimeout(() => {
        if (!nodes[id]) return;
        DM_CHS.forEach(ch => {
          for (let i=0;i<16;i++) document.getElementById(`${id}-step-${ch}-${i}`)?.classList.remove('playing');
          document.getElementById(`${id}-step-${ch}-${stepCopy}`)?.classList.add('playing');
        });
      }, hlMs);
      dmState[id].nextNoteTime += sps;
      dmState[id].currentStep = (step + 1) % 16;
    }
  }
  scheduler();
  dmState[id].intervalId = setInterval(scheduler, 25);
}
function dmStop(id) {
  if (dmState[id]?.intervalId) { clearInterval(dmState[id].intervalId); delete dmState[id]; }
  if (nodes[id]) nodes[id].params.playing = false;
  const btn = document.getElementById(`${id}-dm-btn`);
  if (btn) { btn.textContent = '‚ñ∂ PLAY'; btn.classList.remove('running'); }
  DM_CHS.forEach(ch => {
    for (let i=0;i<16;i++) document.getElementById(`${id}-step-${ch}-${i}`)?.classList.remove('playing');
  });
}

// ‚îÄ‚îÄ‚îÄ Drum synthesis functions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function dmSynthKick(ctx, dst, t, vol) {
  const osc = ctx.createOscillator();
  const ws  = ctx.createWaveShaper();
  const env = ctx.createGain();
  const out = ctx.createGain();
  ws.curve = makeDistortionCurve(25); ws.oversample = '2x';
  osc.type = 'sine';
  osc.frequency.setValueAtTime(150, t);
  osc.frequency.exponentialRampToValueAtTime(50, t + 0.08);
  env.gain.setValueAtTime(0.001, t);
  env.gain.exponentialRampToValueAtTime(1.0, t + 0.003);
  env.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
  out.gain.value = vol * 1.2;
  osc.connect(ws); ws.connect(env); env.connect(out); out.connect(dst);
  osc.start(t); osc.stop(t + 0.5);
}
function dmSynthSnare(ctx, dst, t, vol) {
  const sr = ctx.sampleRate;
  // Noise burst through bandpass
  const nBuf = ctx.createBuffer(1, sr*0.15, sr);
  const nd   = nBuf.getChannelData(0);
  for (let i=0;i<nd.length;i++) nd[i]=Math.random()*2-1;
  const nSrc = ctx.createBufferSource(); nSrc.buffer = nBuf;
  const bpf  = ctx.createBiquadFilter(); bpf.type='bandpass'; bpf.frequency.value=200; bpf.Q.value=0.8;
  const nEnv = ctx.createGain();
  nEnv.gain.setValueAtTime(0.001,t); nEnv.gain.exponentialRampToValueAtTime(0.9,t+0.002);
  nEnv.gain.exponentialRampToValueAtTime(0.001,t+0.1);
  // Tuned body
  const body = ctx.createOscillator(); body.type='sine'; body.frequency.value=185;
  const bEnv = ctx.createGain();
  bEnv.gain.setValueAtTime(0.001,t); bEnv.gain.exponentialRampToValueAtTime(0.7,t+0.002);
  bEnv.gain.exponentialRampToValueAtTime(0.001,t+0.075);
  const out = ctx.createGain(); out.gain.value=vol;
  nSrc.connect(bpf); bpf.connect(nEnv); nEnv.connect(out);
  body.connect(bEnv); bEnv.connect(out); out.connect(dst);
  nSrc.start(t); nSrc.stop(t+0.18); body.start(t); body.stop(t+0.1);
}
function dmSynthClap(ctx, dst, t, vol) {
  const sr  = ctx.sampleRate;
  const out = ctx.createGain(); out.gain.value=vol; out.connect(dst);
  [0, 0.0025, 0.005, 0.0085].forEach((delay, i) => {
    const tt = t + delay;
    const isLast = i===3;
    const dur = isLast ? 0.09 : 0.004;
    const buf = ctx.createBuffer(1, Math.ceil(sr*(isLast?0.1:0.006)), sr);
    const d   = buf.getChannelData(0);
    for (let j=0;j<d.length;j++) d[j]=Math.random()*2-1;
    const src = ctx.createBufferSource(); src.buffer=buf;
    const hpf = ctx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=1000;
    const env = ctx.createGain();
    env.gain.setValueAtTime(0.001,tt); env.gain.exponentialRampToValueAtTime(isLast?1.0:0.6,tt+0.001);
    env.gain.exponentialRampToValueAtTime(0.001,tt+dur);
    src.connect(hpf); hpf.connect(env); env.connect(out);
    src.start(tt); src.stop(tt+dur+0.01);
  });
}
function dmSynthHihat(ctx, dst, t, vol) {
  const sr  = ctx.sampleRate;
  const buf = ctx.createBuffer(1, Math.ceil(sr*0.05), sr);
  const d   = buf.getChannelData(0);
  for (let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
  const src = ctx.createBufferSource(); src.buffer=buf;
  const hpf = ctx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=8000;
  const env = ctx.createGain();
  env.gain.setValueAtTime(0.001,t); env.gain.exponentialRampToValueAtTime(0.9,t+0.001);
  env.gain.exponentialRampToValueAtTime(0.001,t+0.04);
  const out = ctx.createGain(); out.gain.value=vol;
  src.connect(hpf); hpf.connect(env); env.connect(out); out.connect(dst);
  src.start(t); src.stop(t+0.06);
}
function dmSynthOpenhat(ctx, dst, t, vol) {
  const sr  = ctx.sampleRate;
  const buf = ctx.createBuffer(1, Math.ceil(sr*0.35), sr);
  const d   = buf.getChannelData(0);
  for (let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
  const src = ctx.createBufferSource(); src.buffer=buf;
  const hpf = ctx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=7000; hpf.Q.value=2.5;
  const env = ctx.createGain();
  env.gain.setValueAtTime(0.001,t); env.gain.exponentialRampToValueAtTime(0.9,t+0.002);
  env.gain.exponentialRampToValueAtTime(0.001,t+0.3);
  const out = ctx.createGain(); out.gain.value=vol;
  src.connect(hpf); hpf.connect(env); env.connect(out); out.connect(dst);
  src.start(t); src.stop(t+0.38);
}
function dmSynthPerc(ctx, dst, t, vol) {
  const sr  = ctx.sampleRate;
  // Noise burst
  const buf = ctx.createBuffer(1, Math.ceil(sr*0.06), sr);
  const d   = buf.getChannelData(0);
  for (let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
  const nSrc = ctx.createBufferSource(); nSrc.buffer=buf;
  const bpf  = ctx.createBiquadFilter(); bpf.type='bandpass'; bpf.frequency.value=450; bpf.Q.value=1.2;
  const nEnv = ctx.createGain();
  nEnv.gain.setValueAtTime(0.001,t); nEnv.gain.exponentialRampToValueAtTime(0.8,t+0.001);
  nEnv.gain.exponentialRampToValueAtTime(0.001,t+0.055);
  // Pitch-drop oscillator
  const osc = ctx.createOscillator(); osc.type='sine';
  osc.frequency.setValueAtTime(380, t);
  osc.frequency.exponentialRampToValueAtTime(90, t+0.07);
  const oEnv = ctx.createGain();
  oEnv.gain.setValueAtTime(0.001,t); oEnv.gain.exponentialRampToValueAtTime(1.0,t+0.002);
  oEnv.gain.exponentialRampToValueAtTime(0.001,t+0.1);
  const out = ctx.createGain(); out.gain.value=vol;
  nSrc.connect(bpf); bpf.connect(nEnv); nEnv.connect(out);
  osc.connect(oEnv); oEnv.connect(out); out.connect(dst);
  nSrc.start(t); nSrc.stop(t+0.08); osc.start(t); osc.stop(t+0.12);
}

// ‚îÄ‚îÄ‚îÄ Drag nodes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function onHeaderMousedown(e) {
  if (e.target.classList.contains('delete-btn')) return;
  e.preventDefault();
  const id = e.currentTarget.dataset.node;
  dragging = id;
  const el = document.getElementById(id);
  const r = el.getBoundingClientRect();
  dragOffset.x = e.clientX - r.left;
  dragOffset.y = e.clientY - r.top;
  selectNode(id);
}

document.addEventListener('mousemove', e => {
  if (dragging && !isPanning) {
    const cr = canvasEl.getBoundingClientRect();
    const x = Math.max(0, (e.clientX - cr.left - dragOffset.x) / canvasScale - canvasOffset.x);
    const y = Math.max(0, (e.clientY - cr.top  - dragOffset.y) / canvasScale - canvasOffset.y);
    const el = document.getElementById(dragging);
    el.style.left = x+'px'; el.style.top = y+'px';
    nodes[dragging].x = x; nodes[dragging].y = y;
    renderEdges();
    // HP overlap detection ‚Äî tint nodes that collide with the dragged module
    const dw = el.offsetWidth, dh = el.offsetHeight;
    Object.keys(nodes).forEach(oid => {
      if (oid === dragging) return;
      const oel = document.getElementById(oid);
      if (!oel) return;
      const ox=nodes[oid].x, oy=nodes[oid].y, ow=oel.offsetWidth, oh=oel.offsetHeight;
      const overlaps = x < ox+ow && x+dw > ox && y < oy+oh && y+dh > oy;
      oel.classList.toggle('hp-overlap', overlaps);
    });
  }
  if (connecting && !isPanning) {
    const cr = canvasEl.getBoundingClientRect();
    const mx = (e.clientX-cr.left)/canvasScale - canvasOffset.x, my = (e.clientY-cr.top)/canvasScale - canvasOffset.y;
    if (!previewPath) {
      previewPath = document.createElementNS('http://www.w3.org/2000/svg','path');
      previewPath.classList.add('edge-preview');
      svgLayer.appendChild(previewPath);
    }
    const src = getPortPos(connecting.nodeId, connecting.port, connecting.dir);
    const targetDir = connecting.dir==='out'?'in':'out';
    let snapDot=null, snapDist=Infinity;
    document.querySelectorAll(`.port-dot.${targetDir}`).forEach(dot=>{
      if (dot.dataset.node===connecting.nodeId) return;
      const r=dot.getBoundingClientRect();
      const dotX = (r.left+r.width/2-cr.left)/canvasScale - canvasOffset.x;
      const dotY = (r.top+r.height/2-cr.top)/canvasScale - canvasOffset.y;
      const dist=Math.hypot(mx-dotX, my-dotY);
      if (dist<40 && dist<snapDist){snapDist=dist;snapDot=dot;}
    });
    document.querySelectorAll('.port-dot.snap-target').forEach(d=>d.classList.remove('snap-target'));
    if (snapDot) {
      snapDot.classList.add('snap-target');
      const r=snapDot.getBoundingClientRect();
      const snapX = (r.left+r.width/2-cr.left)/canvasScale - canvasOffset.x;
      const snapY = (r.top+r.height/2-cr.top)/canvasScale - canvasOffset.y;
      previewPath.setAttribute('d',bezier(src.x,src.y,snapX,snapY));
    } else {
      previewPath.setAttribute('d',bezier(src.x,src.y,mx,my));
    }
  }
});

document.addEventListener('mouseup', e=>{
  if (dragging) {
    // Drop bounce: connected wires spring, then ripple to one-hop neighbors
    const dropped=dragging;
    dragging=null;
    // Snap x to HP grid, y to 24px dot grid
    const sx=snapHP(nodes[dropped].x), sy=snap(nodes[dropped].y);
    nodes[dropped].x=sx; nodes[dropped].y=sy;
    const snapEl=document.getElementById(dropped);
    if(snapEl){snapEl.style.left=sx+'px'; snapEl.style.top=sy+'px';}
    // Clear all overlap highlights
    document.querySelectorAll('.node.hp-overlap').forEach(el=>el.classList.remove('hp-overlap'));
    renderEdges();
    // Node land animation
    const landEl=document.getElementById(dropped);
    if(landEl){
      landEl.classList.remove('node-land');
      void landEl.offsetWidth; // force reflow to restart animation
      landEl.classList.add('node-land');
      landEl.addEventListener('animationend',()=>landEl.classList.remove('node-land'),{once:true});
    }
    const neighborNodes=new Set();
    edges.forEach(edge=>{
      if(edge.srcNode===dropped||edge.dstNode===dropped){
        const sp=getEdgeSpring(edge);
        sp.y=-32; sp.vy=0; // primary bounce
        // collect the other end of each wire
        neighborNodes.add(edge.srcNode===dropped?edge.dstNode:edge.srcNode);
      }
    });
    // Ripple: wires connected to neighbor nodes (but not the dropped node) get a gentler bounce
    edges.forEach(edge=>{
      if(edge.srcNode===dropped||edge.dstNode===dropped) return; // already handled
      const touchesNeighbor=neighborNodes.has(edge.srcNode)||neighborNodes.has(edge.dstNode);
      if(touchesNeighbor){
        const sp=getEdgeSpring(edge);
        sp.y=-5; sp.vy=0;
      }
    });
  }
  if (connecting && !isPanning) {
    document.querySelectorAll('.port-dot.snap-target').forEach(d=>d.classList.remove('snap-target'));
    const cr=canvasEl.getBoundingClientRect();
    const mx=(e.clientX-cr.left)/canvasScale - canvasOffset.x, my=(e.clientY-cr.top)/canvasScale - canvasOffset.y;
    const targetDir=connecting.dir==='out'?'in':'out';
    let resolved=null;
    if (e.target?.classList?.contains('port-dot') && e.target.dataset.dir===targetDir && e.target.dataset.node!==connecting.nodeId)
      resolved=e.target;
    if (!resolved) {
      let bestDist=Infinity;
      document.querySelectorAll(`.port-dot.${targetDir}`).forEach(dot=>{
        if (dot.dataset.node===connecting.nodeId) return;
        const r=dot.getBoundingClientRect();
        const dotX = (r.left+r.width/2-cr.left)/canvasScale - canvasOffset.x;
        const dotY = (r.top+r.height/2-cr.top)/canvasScale - canvasOffset.y;
        const dist=Math.hypot(mx-dotX,my-dotY);
        if (dist<40 && dist<bestDist){bestDist=dist;resolved=dot;}
      });
    }
    if (resolved) {
      const [sN,sP,dN,dP]=connecting.dir==='out'
        ?[connecting.nodeId,connecting.port,resolved.dataset.node,resolved.dataset.port]
        :[resolved.dataset.node,resolved.dataset.port,connecting.nodeId,connecting.port];
      addEdge(sN,sP,dN,dP);
    }
    if (previewPath){previewPath.remove();previewPath=null;}
    connecting=null;
  }
});

// ‚îÄ‚îÄ‚îÄ Ports ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function onPortMousedown(e) {
  e.preventDefault(); e.stopPropagation();
  connecting={nodeId:e.currentTarget.dataset.node,port:e.currentTarget.dataset.port,dir:e.currentTarget.dataset.dir};
}
function addEdge(sN,sP,dN,dP) {
  if (edges.find(e=>e.srcNode===sN&&e.srcPort===sP&&e.dstNode===dN&&e.dstPort===dP)) return;
  const edge={id:'e'+edges.length,srcNode:sN,srcPort:sP,dstNode:dN,dstPort:dP};
  edges.push(edge);
  // Spring: start pulled upward, falls and bounces into natural droop
  edgeSprings[edgeSpringKey(edge)]={y:-80,vy:0};
  renderEdges(); updateStats();
}
function deleteEdge(idx){edges.splice(idx,1);renderEdges();updateStats();}
function deleteNode(id){
  // Flash-delete connected wires first
  edgeEls.forEach(({pathEl,hitEl,shadowEl,edge})=>{
    if(edge.srcNode===id||edge.dstNode===id){
      pathEl.style.transition='stroke 0.12s, opacity 0.18s';
      pathEl.style.stroke='#f85149'; pathEl.style.opacity='0';
      hitEl.style.pointerEvents='none';
      if(shadowEl){ shadowEl.style.transition='opacity 0.18s'; shadowEl.style.opacity='0'; }
    }
  });
  const el=document.getElementById(id);
  const doRemove=()=>{
    edges=edges.filter(e=>e.srcNode!==id&&e.dstNode!==id);
    el?.remove(); delete nodes[id];
    renderEdges(); updateStats();
  };
  if(el){
    el.classList.add('node-delete');
    el.addEventListener('animationend', doRemove, {once:true});
  } else { doRemove(); }
}
function selectNode(id){
  if(selectedNode) document.getElementById(selectedNode)?.classList.remove('selected');
  selectedNode=id; document.getElementById(id)?.classList.add('selected');
}
function getPortPos(nodeId,portName,dir){
  const el=document.getElementById(nodeId);
  if(!el) return null;
  const cr=canvasEl.getBoundingClientRect();
  for (const p of el.querySelectorAll('.port-dot'))
    if (p.dataset.port===portName&&p.dataset.dir===dir){
      const r=p.getBoundingClientRect();
      return{x:(r.left+r.width/2-cr.left)/canvasScale - canvasOffset.x, y:(r.top+r.height/2-cr.top)/canvasScale - canvasOffset.y};
    }
  const r=el.getBoundingClientRect();
  return{x:(r.left-cr.left)/canvasScale - canvasOffset.x, y:(r.top+r.height/2-cr.top)/canvasScale - canvasOffset.y};
}
function bezier(x1,y1,x2,y2,extraSag=0){
  const dist = Math.hypot(x2-x1, y2-y1);
  // Simulate all cables having a fixed physical length ‚Äî excess becomes sag
  const CABLE_LEN = Math.max(dist * 1.5, 320); // every cable is at least 320px "long"
  const slack = CABLE_LEN - dist;
  const sag = Math.min(slack * 0.38 + 45, 210) + extraSag;

  // Horizontal routing: only as wide as the actual x-gap (stops weird sideways kinks)
  const hGap = x2 - x1;
  const dx = Math.max(Math.abs(hGap) * 0.35, 20);

  // Control points pull downward (gravity) ‚Äî same Y offset regardless of angle
  return `M${x1} ${y1} C${x1+dx} ${y1+sag*0.85},${x2-dx} ${y2+sag*0.85},${x2} ${y2}`;
}
// Eurorack patch cable color palette ‚Äî distinct, saturated, like real modular cables
const CABLE_COLORS = [
  '#ff3d3d', // red
  '#ffab00', // amber
  '#00e676', // green
  '#40c4ff', // light blue
  '#ff6d00', // orange
  '#e040fb', // magenta
  '#00e5ff', // cyan
  '#ffff00', // yellow
  '#ff4081', // pink
  '#69f0ae', // mint
  '#448aff', // blue
  '#ff6e40', // deep orange
];

function renderEdges(){
  svgLayer.querySelectorAll('.edge-path,.edge-hit,.edge-shadow,.edge-tip').forEach(p=>p.remove());
  edgeEls=[];
  edges.forEach((edge,idx)=>{
    if(!nodes[edge.srcNode]||!nodes[edge.dstNode]) return;
    const src=getPortPos(edge.srcNode,edge.srcPort,'out');
    const dst=getPortPos(edge.dstNode,edge.dstPort,'in');
    const d=bezier(src.x,src.y,dst.x,dst.y);
    // Each cable gets its own color from the palette by index
    const color = CABLE_COLORS[idx % CABLE_COLORS.length];

    function grabEdge(e){
      e.preventDefault(); e.stopPropagation();
      const cr=canvasEl.getBoundingClientRect();
      const mx=(e.clientX-cr.left)/canvasScale - canvasOffset.x, my=(e.clientY-cr.top)/canvasScale - canvasOffset.y;
      const dSrc=Math.hypot(mx-src.x,my-src.y);
      const dDst=Math.hypot(mx-dst.x,my-dst.y);
      const fixedNode = dDst<=dSrc ? edge.srcNode : edge.dstNode;
      const fixedPort = dDst<=dSrc ? edge.srcPort : edge.dstPort;
      const fixedDir  = dDst<=dSrc ? 'out'        : 'in';
      deleteEdge(idx);
      connecting={nodeId:fixedNode, port:fixedPort, dir:fixedDir};
    }

    // Shadow pass ‚Äî gives cable depth/thickness illusion
    const shadow=document.createElementNS('http://www.w3.org/2000/svg','path');
    shadow.classList.add('edge-shadow'); shadow.setAttribute('d',d);
    shadow.setAttribute('stroke','#000000');
    svgLayer.insertBefore(shadow,previewPath);

    // Hit target
    const hit=document.createElementNS('http://www.w3.org/2000/svg','path');
    hit.classList.add('edge-hit'); hit.setAttribute('d',d);
    hit.addEventListener('mousedown', grabEdge);
    svgLayer.insertBefore(hit,previewPath);

    // Cable path
    const path=document.createElementNS('http://www.w3.org/2000/svg','path');
    path.classList.add('edge-path'); path.setAttribute('d',d); path.setAttribute('stroke',color);
    path.addEventListener('mousedown', grabEdge);
    svgLayer.insertBefore(path,previewPath);

    // Jack tip circles at both ends ‚Äî look like the cable plug
    [src, dst].forEach(pt => {
      const tip=document.createElementNS('http://www.w3.org/2000/svg','circle');
      tip.classList.add('edge-tip');
      tip.setAttribute('cx', pt.x); tip.setAttribute('cy', pt.y);
      tip.setAttribute('r', '5');
      tip.setAttribute('fill', color);
      tip.setAttribute('stroke', '#000'); tip.setAttribute('stroke-width', '1.5');
      svgLayer.insertBefore(tip, previewPath);
    });

    // Store refs for wire animation
    edgeEls.push({pathEl:path, hitEl:hit, shadowEl:shadow, edge});
  });
}

// ‚îÄ‚îÄ‚îÄ Wire physics animation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function animateWires(){
  wireRafId=requestAnimationFrame(animateWires);
  edgeEls.forEach(({pathEl,hitEl,shadowEl,edge})=>{
    if(!nodes[edge.srcNode]||!nodes[edge.dstNode]) return;
    const src=getPortPos(edge.srcNode,edge.srcPort,'out');
    const dst=getPortPos(edge.dstNode,edge.dstPort,'in');
    if(!src||!dst) return;
    // Spring physics: settle toward y=0 (natural sag position)
    const sp=getEdgeSpring(edge);
    sp.vy += -0.12 * sp.y; // spring force
    sp.vy *= 0.86;          // damping ‚Äî looser = more oscillations
    sp.y  += sp.vy;
    if(Math.abs(sp.y)<0.1&&Math.abs(sp.vy)<0.05) sp.y=sp.vy=0; // settle
    const d=bezier(src.x,src.y,dst.x,dst.y,sp.y);
    pathEl.setAttribute('d',d);
    hitEl.setAttribute('d',d);
    if(shadowEl) shadowEl.setAttribute('d',d);
  });
}
animateWires(); // DOM is ready since script is at end of body

// ‚îÄ‚îÄ‚îÄ Palette drag/drop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.querySelectorAll('.palette-item').forEach(item=>
  item.addEventListener('dragstart',e=>e.dataTransfer.setData('type',item.dataset.type)));
canvasEl.addEventListener('dragover',e=>e.preventDefault());
canvasEl.addEventListener('drop',e=>{
  e.preventDefault();
  const type=e.dataTransfer.getData('type'); if(!type) return;
  const cr=canvasEl.getBoundingClientRect();
  const id=createNode(type,snap((e.clientX-cr.left)/canvasScale - canvasOffset.x - 85),snap((e.clientY-cr.top)/canvasScale - canvasOffset.y - 30));
  // Land animation on palette drop
  requestAnimationFrame(()=>{
    const el=document.getElementById(id);
    if(el){ el.classList.add('node-land'); el.addEventListener('animationend',()=>el.classList.remove('node-land'),{once:true}); }
  });
});

// ‚îÄ‚îÄ‚îÄ Audio helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function makeDistortionCurve(amount){
  const n=256,curve=new Float32Array(n);
  for(let i=0;i<n;i++){const x=(i*2)/n-1;curve[i]=((Math.PI+amount)*x)/(Math.PI+amount*Math.abs(x));}
  return curve;
}
function makeReverbIR(ctx,duration,decay){
  const len=ctx.sampleRate*duration;
  const buf=ctx.createBuffer(2,len,ctx.sampleRate);
  for(let c=0;c<2;c++){
    const d=buf.getChannelData(c);
    for(let i=0;i<len;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/len,decay);
  }
  return buf;
}

// ‚îÄ‚îÄ‚îÄ Audio engine ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function setMasterVol(v) {
  document.getElementById('vol-pct').textContent = Math.round(v*100)+'%';
  if (masterGain) masterGain.gain.setTargetAtTime(+v, audioCtx.currentTime, 0.01);
}

function startAudio(){
  if(audioCtx) return;
  audioCtx=new(window.AudioContext||window.webkitAudioContext)();
  audioNodes={};
  masterGain=audioCtx.createGain();
  masterGain.gain.value=+document.getElementById('master-vol').value;
  // Limiter to prevent clipping when signals sum loud
  const limiter=audioCtx.createDynamicsCompressor();
  limiter.threshold.value=-18; limiter.knee.value=6;
  limiter.ratio.value=20; limiter.attack.value=0.001; limiter.release.value=0.15;
  masterGain.connect(limiter);
  limiter.connect(audioCtx.destination);

  Object.values(nodes).forEach(n=>{
    const p=n.params;
    switch(n.type){
      case'oscillator':{
        const osc=audioCtx.createOscillator();
        osc.type=p.wave; osc.frequency.value=+p.freq;
        audioNodes[n.id]={main:osc,input:null,output:osc,
          audioParams:{freq_mod:osc.frequency}};
        break;
      }
      case'noise':{
        const sz=audioCtx.sampleRate*2;
        const buf=audioCtx.createBuffer(1,sz,audioCtx.sampleRate);
        const d=buf.getChannelData(0);
        for(let i=0;i<sz;i++) d[i]=Math.random()*2-1;
        const src=audioCtx.createBufferSource();
        src.buffer=buf; src.loop=true;
        const g=audioCtx.createGain(); g.gain.value=+p.level;
        src.connect(g);
        audioNodes[n.id]={main:src,gainNode:g,input:null,output:g};
        break;
      }
      case'gain':{
        const g=audioCtx.createGain(); g.gain.value=+p.gain;
        audioNodes[n.id]={main:g,input:g,output:g};
        break;
      }
      case'pan':{
        const panner=audioCtx.createStereoPanner(); panner.pan.value=+p.pan;
        audioNodes[n.id]={main:panner,input:panner,output:panner,audioParams:{pan_mod:panner.pan}};
        break;
      }
      case'filter':{
        const f=audioCtx.createBiquadFilter();
        f.type=p.type; f.frequency.value=+p.freq; f.Q.value=+p.q;
        audioNodes[n.id]={main:f,input:f,output:f,
          audioParams:{freq_mod:f.frequency}};
        break;
      }
      case'delay':{
        const d=audioCtx.createDelay(10); d.delayTime.value=+p.time;
        const fb=audioCtx.createGain(); fb.gain.value=+p.feedback;
        d.connect(fb); fb.connect(d);
        audioNodes[n.id]={main:d,feedback:fb,input:d,output:d};
        break;
      }
      case'ping_pong':{
        const delayL=audioCtx.createDelay(2.0); delayL.delayTime.value=+p.timeL;
        const delayR=audioCtx.createDelay(2.0); delayR.delayTime.value=+p.timeR;
        const fbL=audioCtx.createGain(); fbL.gain.value=+p.feedback;
        const fbR=audioCtx.createGain(); fbR.gain.value=+p.feedback;
        const merge=audioCtx.createChannelMerger(2);
        const dry=audioCtx.createGain(); dry.gain.value=1-+p.wet;
        const wet=audioCtx.createGain(); wet.gain.value=+p.wet;
        const input=audioCtx.createGain();
        const output=audioCtx.createGain();
        input.connect(delayL);
        delayL.connect(fbL); fbL.connect(delayR);
        delayR.connect(fbR); fbR.connect(delayL);
        delayL.connect(merge,0,0);
        delayR.connect(merge,0,1);
        merge.connect(wet); wet.connect(output);
        input.connect(dry); dry.connect(output);
        audioNodes[n.id]={main:output,input,output,delayL,delayR,fbL,fbR,dry,wet};
        break;
      }
      case'reverb':{
        const conv=audioCtx.createConvolver();
        conv.buffer=makeReverbIR(audioCtx,+p.duration,+p.decay);
        const dry=audioCtx.createGain(); dry.gain.value=1-+p.wet;
        const wet=audioCtx.createGain(); wet.gain.value=+p.wet;
        const inn=audioCtx.createGain();  // input splitter
        const out=audioCtx.createGain();  // output merger
        inn.connect(dry); inn.connect(conv); conv.connect(wet);
        dry.connect(out); wet.connect(out);
        audioNodes[n.id]={main:conv,input:inn,output:out,dry,wet:wet};
        break;
      }
      case'distortion':{
        const ws=audioCtx.createWaveShaper();
        ws.curve=makeDistortionCurve(+p.amount); ws.oversample='4x';
        audioNodes[n.id]={main:ws,input:ws,output:ws};
        break;
      }
      case'compressor':{
        const c=audioCtx.createDynamicsCompressor();
        c.threshold.value=+p.threshold; c.ratio.value=+p.ratio; c.knee.value=+p.knee;
        audioNodes[n.id]={main:c,input:c,output:c};
        break;
      }
      case'mixer':{
        const ch1=audioCtx.createGain(); ch1.gain.value=+p.gain1;
        const ch2=audioCtx.createGain(); ch2.gain.value=+p.gain2;
        const ch3=audioCtx.createGain(); ch3.gain.value=+p.gain3;
        const out=audioCtx.createGain(); out.gain.value=1;
        ch1.connect(out); ch2.connect(out); ch3.connect(out);
        audioNodes[n.id]={main:out, input:ch1, inputs:{ch1,ch2,ch3}, output:out, ch1,ch2,ch3};
        break;
      }
      case'lfo':{
        const osc=audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value=+p.freq;
        const depth=audioCtx.createGain(); depth.gain.value=+p.depth;
        osc.connect(depth);
        audioNodes[n.id]={osc,depth,main:osc,input:null,output:depth};
        break;
      }
      case'speaker':{
        const analyser=audioCtx.createAnalyser(); analyser.fftSize=256;
        analyser.connect(masterGain);
        audioNodes[n.id]={main:analyser,input:analyser,output:analyser,analyser};
        break;
      }
      case'oscilloscope':{
        const analyser=audioCtx.createAnalyser(); analyser.fftSize=512;
        audioNodes[n.id]={main:analyser,input:analyser,output:analyser,analyser};
        break;
      }
      case'spectrum':{
        const analyser=audioCtx.createAnalyser(); analyser.fftSize=2048;
        audioNodes[n.id]={main:analyser,input:analyser,output:analyser,analyser};
        break;
      }
      case'xy_scope':{
        const analyserX=audioCtx.createAnalyser(); analyserX.fftSize=512;
        const analyserY=audioCtx.createAnalyser(); analyserY.fftSize=512;
        audioNodes[n.id]={main:analyserX,input:analyserX,output:null,
          analyserX,analyserY, inputs:{x:analyserX,y:analyserY}};
        break;
      }
      case'stereo_scope':{
        const analyserL=audioCtx.createAnalyser(); analyserL.fftSize=512;
        const analyserR=audioCtx.createAnalyser(); analyserR.fftSize=512;
        audioNodes[n.id]={main:analyserL,input:analyserL,output:null,
          analyserL,analyserR, inputs:{L:analyserL,R:analyserR}};
        break;
      }
      case'sequencer':{
        // No real Web Audio node ‚Äî sequencer drives connected osc frequencies via JS timing
        audioNodes[n.id]={main:null,input:null,output:null};
        break;
      }
      case'keyboard':{
        // No audio node ‚Äî keyboard drives connected oscillator frequencies via JS events
        audioNodes[n.id]={main:null,input:null,output:null};
        break;
      }
      case'envelope':{
        const envGain=audioCtx.createGain(); envGain.gain.value=0;
        audioNodes[n.id]={main:envGain,input:envGain,output:envGain};
        break;
      }
      case'drum_machine':{
        // Drum machine ‚Äî output GainNode collects all synthesized voices
        const dmOut=audioCtx.createGain(); dmOut.gain.value=1.0;
        audioNodes[n.id]={main:dmOut,input:null,output:dmOut};
        break;
      }
    }
  });

  // Wire edges (skip sequencer/keyboard non-audio ports)
  edges.forEach(edge=>{
    if(nodes[edge.srcNode]?.type==='sequencer') return; // handled separately
    if(nodes[edge.srcNode]?.type==='keyboard') return; // handled via kbPress JS events
    if(edge.srcPort==='gate'||edge.dstPort==='gate') return; // gate is a control signal, not audio
    const src=audioNodes[edge.srcNode], dst=audioNodes[edge.dstNode];
    if(!src||!dst) return;
    // AudioParam modulation (e.g. freq_mod ‚Üí filter.frequency)
    const dstParam  = dst.audioParams?.[edge.dstPort];
    // per-port input routing (e.g. mixer channels)
    const dstInput  = dst.inputs?.[edge.dstPort] ?? dst.input;
    const target = dstParam ?? dstInput;
    if(!target) return;
    try{src.output.connect(target);}catch(e){console.warn('connect failed',e);}
  });

  // Start sources
  Object.values(audioNodes).forEach(an=>{
    try{if(an.osc)an.osc.start();else if(an.main?.start)an.main.start();}catch(e){}
  });

  // Start sequencers
  Object.values(nodes).filter(n=>n.type==='sequencer').forEach(n=>{
    seqState[n.id]={step:0};
    const tick=()=>{
      if(!audioCtx||!nodes[n.id]) return;
      const p=nodes[n.id].params;
      const step=seqState[n.id].step;
      // Clear previous playing highlights
      for(let i=0;i<8;i++) document.getElementById(`${n.id}-s${i}`)?.classList.remove('playing');
      if(p.active[step]){
        const freq=p.notes[step];
        edges.filter(e=>e.srcNode===n.id).forEach(e=>{
          const an=audioNodes[e.dstNode];
          if(an?.main?.frequency) an.main.frequency.setValueAtTime(freq, audioCtx.currentTime);
        });
      }
      document.getElementById(`${n.id}-s${step}`)?.classList.add('playing');
      seqState[n.id].step=(step+1)%8;
    };
    tick(); // fire first step immediately
    seqState[n.id].intervalId=setInterval(tick, 60000/+n.params.bpm);
  });

  // Start drum machines that were playing before audio restart
  Object.values(nodes).filter(n=>n.type==='drum_machine').forEach(n=>{
    // Auto-start only if params.playing was true (e.g. preset restore)
    if (n.params.playing) setTimeout(()=>dmStart(n.id), 100);
  });

  // Animation loop ‚Äî VU + scope
  function drawLoop(){
    rafId=requestAnimationFrame(drawLoop);
    // VU meters
    Object.values(nodes).filter(n=>n.type==='speaker').forEach(n=>{
      const an=audioNodes[n.id]; const el=document.getElementById(n.id+'-vu');
      if(!an?.analyser||!el) return;
      const data=new Uint8Array(an.analyser.frequencyBinCount);
      an.analyser.getByteTimeDomainData(data);
      const rms=Math.sqrt(data.reduce((a,v)=>a+Math.pow((v-128)/128,2),0)/data.length);
      el.style.width=Math.min(100,rms*400)+'%';
    });
    // Oscilloscopes
    const now=performance.now()*0.001;
    Object.values(nodes).filter(n=>n.type==='oscilloscope').forEach(n=>{
      const an=audioNodes[n.id];
      const canvas=document.getElementById(n.id+'-scope');
      if(!an?.analyser||!canvas) return;
      const ctx=canvas.getContext('2d');
      const W=canvas.width, H=canvas.height;
      const data=new Uint8Array(an.analyser.fftSize);
      an.analyser.getByteTimeDomainData(data);
      const zoom=+nodes[n.id].params.zoom||1;
      const mode=nodes[n.id].params.mode||'standard';

      // Background / trail
      if(mode==='standard'){
        ctx.fillStyle='#000810'; ctx.fillRect(0,0,W,H);
      } else if(mode==='phosphor'){
        ctx.fillStyle='rgba(0,8,16,0.35)'; ctx.fillRect(0,0,W,H);
      } else { // trippy
        ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(0,0,W,H);
      }

      // Grid
      ctx.strokeStyle='rgba(0,100,40,0.25)'; ctx.lineWidth=0.5;
      for(let i=1;i<4;i++){
        ctx.beginPath(); ctx.moveTo(0,H*i/4); ctx.lineTo(W,H*i/4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*i/4,0); ctx.lineTo(W*i/4,H); ctx.stroke();
      }

      // Waveform ‚Äî find trigger point (zero crossing going up)
      let start=0;
      for(let i=1;i<data.length/2;i++){
        if(data[i-1]<128&&data[i]>=128){start=i;break;}
      }
      const visLen=Math.min(data.length-start, Math.floor(data.length/zoom));

      if(mode==='trippy'){
        // Ring buffer for echo effect ‚Äî keep last 10 frames
        if(!scopeHistory[n.id]) scopeHistory[n.id]=[];
        scopeHistory[n.id].push(new Uint8Array(data.buffer.slice(0)));
        if(scopeHistory[n.id].length>10) scopeHistory[n.id].shift();
        // Draw echoes oldest‚Üínewest at decreasing opacity
        scopeHistory[n.id].forEach((frame,fi,arr)=>{
          const age=arr.length-1-fi; // 0=newest
          const alpha=0.12+0.08*(arr.length-1-age)/arr.length;
          const hueShift=(fi/arr.length*120+now*60)%360;
          ctx.lineWidth=1.5; ctx.shadowBlur=0;
          let first=true;
          ctx.beginPath();
          for(let i=0;i<visLen;i++){
            const x=(i/visLen)*W;
            let y=H/2-(frame[start+i]-128)/128*(H/2)*0.9;
            y+=Math.sin(now*2+i*0.12+fi*0.8)*((frame[start+i]-128)/128)*(H/2)*0.12;
            first?ctx.moveTo(x,y):ctx.lineTo(x,y); first=false;
          }
          const hue=(hueShift+age*25)%360;
          ctx.strokeStyle=`hsla(${hue},100%,65%,${alpha+(fi===arr.length-1?0.7:0)})`;
          if(fi===arr.length-1){ ctx.lineWidth=2; ctx.shadowBlur=8; ctx.shadowColor=`hsl(${hue},100%,65%)`; }
          ctx.stroke(); ctx.shadowBlur=0;
        });
      } else if(mode==='phosphor'){
        // Chromatic aberration ‚Äî red channel shifted left
        ctx.beginPath(); ctx.strokeStyle='rgba(255,30,30,0.3)'; ctx.lineWidth=1;
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W-2;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Blue channel shifted right
        ctx.beginPath(); ctx.strokeStyle='rgba(30,180,255,0.3)'; ctx.lineWidth=1;
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W+2;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Wide soft outer glow pass
        ctx.beginPath(); ctx.strokeStyle='rgba(0,255,80,0.15)'; ctx.lineWidth=8;
        ctx.shadowBlur=20; ctx.shadowColor='#00ff55';
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Medium glow pass
        ctx.beginPath(); ctx.strokeStyle='rgba(0,255,80,0.4)'; ctx.lineWidth=3;
        ctx.shadowBlur=12; ctx.shadowColor='#00ff55';
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Bright core
        ctx.beginPath(); ctx.strokeStyle='#ccffdd'; ctx.lineWidth=1;
        ctx.shadowBlur=4; ctx.shadowColor='#00ff55';
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Scan lines artifact
        ctx.fillStyle='rgba(0,0,0,0.08)';
        for(let y=0;y<H;y+=2) ctx.fillRect(0,y,W,1);
        ctx.shadowBlur=0;
      } else {
        ctx.beginPath(); ctx.strokeStyle='#e0e0e0'; ctx.lineWidth=1.5; ctx.shadowBlur=0;
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
      }
      ctx.shadowBlur=0;
    });

    // Spectrum Analyzers
    Object.values(nodes).filter(n=>n.type==='spectrum').forEach(n=>{
      const an=audioNodes[n.id];
      const canvas=document.getElementById(n.id+'-scope');
      if(!an?.analyser||!canvas) return;
      const ctx=canvas.getContext('2d');
      const W=canvas.width, H=canvas.height;
      const mode=nodes[n.id].params.mode||'standard';
      const data=new Uint8Array(an.analyser.frequencyBinCount);
      an.analyser.getByteFrequencyData(data);
      const bins=Math.min(data.length, 128); // use first 128 bins for display

      if(mode==='standard'){
        ctx.fillStyle='#000810'; ctx.fillRect(0,0,W,H);
      } else if(mode==='phosphor'){
        ctx.fillStyle='rgba(0,8,16,0.35)'; ctx.fillRect(0,0,W,H);
      } else {
        ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(0,0,W,H);
      }
      // Grid
      ctx.strokeStyle='rgba(0,100,40,0.2)'; ctx.lineWidth=0.5;
      for(let i=1;i<4;i++){ctx.beginPath();ctx.moveTo(0,H*i/4);ctx.lineTo(W,H*i/4);ctx.stroke();}

      const bw=W/bins;
      if(mode==='phosphor'){
        // Draw bars with 3 passes: outer glow, mid, bright core + scan lines
        for(let i=0;i<bins;i++){
          const bh=(data[i]/255)*H, x=i*bw, y=H-bh;
          // Outer glow
          ctx.shadowBlur=12; ctx.shadowColor='#00ff55';
          ctx.fillStyle='rgba(0,255,80,0.15)';
          ctx.fillRect(x, y-2, bw, bh+2);
          // Mid
          ctx.shadowBlur=6;
          ctx.fillStyle='rgba(0,255,80,0.5)';
          ctx.fillRect(x+0.5, y, bw-1, bh);
          // Bright cap
          ctx.shadowBlur=3;
          ctx.fillStyle='#ccffdd';
          ctx.fillRect(x+0.5, y, bw-1, Math.min(2, bh));
        }
        // Scan lines
        ctx.shadowBlur=0; ctx.fillStyle='rgba(0,0,0,0.08)';
        for(let y=0;y<H;y+=2) ctx.fillRect(0,y,W,1);
      } else if(mode==='trippy'){
        // Echo: store frame, draw ghosts
        if(!scopeHistory[n.id]) scopeHistory[n.id]=[];
        scopeHistory[n.id].push(new Uint8Array(data.buffer.slice(0)));
        if(scopeHistory[n.id].length>8) scopeHistory[n.id].shift();
        scopeHistory[n.id].forEach((frame,fi,arr)=>{
          const age=arr.length-1-fi;
          const alpha=age===0?0.9:0.1+0.06*(arr.length-age)/arr.length;
          ctx.shadowBlur=age===0?8:0;
          for(let i=0;i<bins;i++){
            const bh=(frame[i]/255)*H, x=i*bw, y=H-bh;
            const hue=(i/bins*300+now*40+fi*35)%360;
            ctx.fillStyle=`hsla(${hue},100%,60%,${alpha})`;
            ctx.shadowColor=`hsl(${hue},100%,60%)`;
            ctx.fillRect(x+0.5, y, bw-1, bh);
          }
          ctx.shadowBlur=0;
        });
      } else {
        for(let i=0;i<bins;i++){
          const bh=(data[i]/255)*H, x=i*bw, y=H-bh;
          ctx.fillStyle='#00cc44';
          ctx.fillRect(x+0.5, y, bw-1, bh);
        }
      }
      ctx.shadowBlur=0;
    });

    // XY / Lissajous scopes
    Object.values(nodes).filter(n=>n.type==='xy_scope').forEach(n=>{
      const an=audioNodes[n.id];
      const canvas=document.getElementById(n.id+'-scope');
      if(!an?.analyserX||!canvas) return;
      const ctx=canvas.getContext('2d');
      const W=canvas.width, H=canvas.height;
      const mode=nodes[n.id].params.mode||'standard';
      const dataX=new Uint8Array(an.analyserX.fftSize);
      const dataY=new Uint8Array(an.analyserY.fftSize);
      an.analyserX.getByteTimeDomainData(dataX);
      an.analyserY.getByteTimeDomainData(dataY);
      const len=Math.min(dataX.length, dataY.length);

      // Grid
      ctx.strokeStyle='rgba(0,100,40,0.25)'; ctx.lineWidth=0.5;
      for(let i=1;i<4;i++){ctx.beginPath();ctx.moveTo(0,H*i/4);ctx.lineTo(W,H*i/4);ctx.stroke();ctx.beginPath();ctx.moveTo(W*i/4,0);ctx.lineTo(W*i/4,H);ctx.stroke();}

      const drawXYPath=(dx,dy,strokeStyle,lw,blur,blurColor)=>{
        ctx.beginPath(); ctx.strokeStyle=strokeStyle; ctx.lineWidth=lw;
        ctx.shadowBlur=blur; if(blurColor) ctx.shadowColor=blurColor;
        for(let i=0;i<len;i++){
          const x=((dx[i]-128)/128)*(W/2-2)+W/2;
          const y=((dy[i]-128)/128)*(H/2-2)+H/2;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke(); ctx.shadowBlur=0;
      };

      if(mode==='phosphor'){
        // Chromatic aberration ‚Äî red shifted left, blue shifted right
        ctx.beginPath(); ctx.strokeStyle='rgba(255,40,40,0.25)'; ctx.lineWidth=1; ctx.shadowBlur=0;
        for(let i=0;i<len;i++){
          const x=((dataX[i]-128)/128)*(W/2-2)+W/2-2;
          const y=((dataY[i]-128)/128)*(H/2-2)+H/2;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        ctx.beginPath(); ctx.strokeStyle='rgba(30,180,255,0.25)'; ctx.lineWidth=1; ctx.shadowBlur=0;
        for(let i=0;i<len;i++){
          const x=((dataX[i]-128)/128)*(W/2-2)+W/2+2;
          const y=((dataY[i]-128)/128)*(H/2-2)+H/2;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Outer glow
        drawXYPath(dataX,dataY,'rgba(0,255,80,0.15)',8,20,'#00ff55');
        // Mid glow
        drawXYPath(dataX,dataY,'rgba(0,255,80,0.45)',3,10,'#00ff55');
        // Bright core
        drawXYPath(dataX,dataY,'#ccffdd',1,4,'#00ff55');
        // Scan lines
        ctx.fillStyle='rgba(0,0,0,0.08)';
        for(let y=0;y<H;y+=2) ctx.fillRect(0,y,W,1);
      } else if(mode==='trippy'){
        if(!scopeHistory[n.id]) scopeHistory[n.id]=[];
        scopeHistory[n.id].push({x:new Uint8Array(dataX.buffer.slice(0)), y:new Uint8Array(dataY.buffer.slice(0))});
        if(scopeHistory[n.id].length>10) scopeHistory[n.id].shift();
        scopeHistory[n.id].forEach((frame,fi,arr)=>{
          const age=arr.length-1-fi;
          const alpha=age===0?0.85:0.08+0.06*(arr.length-age)/arr.length;
          const hue=(fi/arr.length*360+now*80)%360;
          ctx.beginPath();
          ctx.strokeStyle=`hsla(${hue},100%,65%,${alpha})`;
          ctx.lineWidth=age===0?2:1.5;
          ctx.shadowBlur=age===0?8:0; ctx.shadowColor=`hsl(${hue},100%,65%)`;
          for(let i=0;i<len;i++){
            const x=((frame.x[i]-128)/128)*(W/2-2)+W/2;
            const y=((frame.y[i]-128)/128)*(H/2-2)+H/2;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke(); ctx.shadowBlur=0;
        });
      } else {
        drawXYPath(dataX,dataY,'#00cc44',1.5,0);
      }
      ctx.shadowBlur=0;
    });

    // Stereo scopes
    Object.values(nodes).filter(n=>n.type==='stereo_scope').forEach(n=>{
      const an=audioNodes[n.id];
      const canvas=document.getElementById(n.id+'-scope');
      if(!an?.analyserL||!canvas) return;
      const ctx=canvas.getContext('2d');
      const W=canvas.width, H=canvas.height;
      const mode=nodes[n.id].params.mode||'standard';
      const dataL=new Uint8Array(an.analyserL.fftSize);
      const dataR=new Uint8Array(an.analyserR.fftSize);
      an.analyserL.getByteTimeDomainData(dataL);
      an.analyserR.getByteTimeDomainData(dataR);

      if(mode==='standard'){
        ctx.fillStyle='#000810'; ctx.fillRect(0,0,W,H);
      } else if(mode==='phosphor'){
        ctx.fillStyle='rgba(0,8,16,0.35)'; ctx.fillRect(0,0,W,H);
      } else {
        ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(0,0,W,H);
      }
      // Grid: horizontal center divider
      ctx.strokeStyle='rgba(0,100,40,0.3)'; ctx.lineWidth=0.5;
      ctx.beginPath(); ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.stroke();
      for(let i=1;i<4;i++){ctx.beginPath();ctx.moveTo(W*i/4,0);ctx.lineTo(W*i/4,H);ctx.stroke();}

      // Trippy: maintain history
      if(mode==='trippy'){
        if(!scopeHistory[n.id]) scopeHistory[n.id]=[];
        scopeHistory[n.id].push({L:new Uint8Array(dataL.buffer.slice(0)), R:new Uint8Array(dataR.buffer.slice(0))});
        if(scopeHistory[n.id].length>10) scopeHistory[n.id].shift();
      }

      // Draw L (top half) and R (bottom half)
      [[null,0,H/2,'L',0],[null,H/2,H,'R',1]].forEach(([_,y0,y1,ch,ci])=>{
        const hH=y1-y0;
        // find trigger in current data (used for all modes)
        const curData=ci===0?dataL:dataR;
        let start=0;
        for(let i=1;i<curData.length/2;i++){if(curData[i-1]<128&&curData[i]>=128){start=i;break;}}
        const vLen=Math.min(curData.length-start, curData.length);

        if(mode==='trippy'){
          // Draw echo frames
          (scopeHistory[n.id]||[]).forEach((frame,fi,arr)=>{
            const data=ci===0?frame.L:frame.R;
            const age=arr.length-1-fi;
            const alpha=age===0?0.85:0.08+0.05*(arr.length-age)/arr.length;
            const hue=(fi/arr.length*360+now*50+ci*140)%360;
            ctx.beginPath();
            ctx.strokeStyle=`hsla(${hue},100%,65%,${alpha})`;
            ctx.lineWidth=age===0?2:1.5;
            ctx.shadowBlur=age===0?8:0; ctx.shadowColor=`hsl(${hue},100%,65%)`;
            for(let i=0;i<vLen;i++){
              const x=(i/vLen)*W;
              let y=y0+hH/2-(data[start+i]-128)/128*(hH/2)*0.85;
              y+=Math.sin(now*1.3+i*0.08+fi*0.6+ci*3)*((data[start+i]-128)/128)*(hH/2)*0.12;
              i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
            }
            ctx.stroke(); ctx.shadowBlur=0;
          });
        } else if(mode==='phosphor'){
          const col=ci===0?'#00ffcc':'#ffaa00';
          const colRgb=ci===0?'0,255,200':'255,170,0';
          // Chromatic aberration
          ctx.beginPath(); ctx.strokeStyle=`rgba(255,40,40,0.2)`; ctx.lineWidth=1; ctx.shadowBlur=0;
          for(let i=0;i<vLen;i++){
            const x=(i/vLen)*W-1.5;
            const y=y0+hH/2-(curData[start+i]-128)/128*(hH/2)*0.85;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke();
          // Outer glow
          ctx.beginPath(); ctx.strokeStyle=`rgba(${colRgb},0.15)`; ctx.lineWidth=8; ctx.shadowBlur=16; ctx.shadowColor=col;
          for(let i=0;i<vLen;i++){
            const x=(i/vLen)*W; const y=y0+hH/2-(curData[start+i]-128)/128*(hH/2)*0.85;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke();
          // Mid
          ctx.beginPath(); ctx.strokeStyle=`rgba(${colRgb},0.5)`; ctx.lineWidth=2.5; ctx.shadowBlur=8; ctx.shadowColor=col;
          for(let i=0;i<vLen;i++){
            const x=(i/vLen)*W; const y=y0+hH/2-(curData[start+i]-128)/128*(hH/2)*0.85;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke();
          // Core
          ctx.beginPath(); ctx.strokeStyle='rgba(220,255,240,0.9)'; ctx.lineWidth=1; ctx.shadowBlur=3; ctx.shadowColor=col;
          for(let i=0;i<vLen;i++){
            const x=(i/vLen)*W; const y=y0+hH/2-(curData[start+i]-128)/128*(hH/2)*0.85;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke(); ctx.shadowBlur=0;
        } else {
          ctx.beginPath(); ctx.strokeStyle=ci===0?'#5da0d0':'#d6a058'; ctx.lineWidth=1.5; ctx.shadowBlur=0;
          for(let i=0;i<vLen;i++){
            const x=(i/vLen)*W; const y=y0+hH/2-(curData[start+i]-128)/128*(hH/2)*0.85;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke();
        }

        // Scan lines (phosphor only)
        if(mode==='phosphor'){
          ctx.fillStyle='rgba(0,0,0,0.07)';
          for(let y=y0;y<y1;y+=2) ctx.fillRect(0,y,W,1);
        }

        // Channel label
        ctx.fillStyle=mode==='standard'?(ci===0?'#5da0d0':'#d6a058'):'rgba(255,255,255,0.3)';
        ctx.font='7px monospace'; ctx.fillText(ch, 3, y0+9);
      });
    });
  }
  drawLoop();

  Object.keys(nodes).forEach(id=>document.getElementById(id)?.classList.add('running'));
  document.getElementById('play-btn').style.display='none';
  document.getElementById('stop-btn').style.display='inline-block';
  document.getElementById('status-msg').textContent='‚ñ∂ playing';
}

function stopAudio(){
  if(!audioCtx) return;
  if(rafId){cancelAnimationFrame(rafId);rafId=null;}
  // Stop sequencer intervals + clear step highlights
  Object.entries(seqState).forEach(([id,st])=>{
    clearInterval(st.intervalId);
    for(let i=0;i<8;i++) document.getElementById(`${id}-s${i}`)?.classList.remove('playing');
  });
  seqState={};
  // Stop drum machine schedulers
  Object.keys(dmState).forEach(id=>{
    clearInterval(dmState[id].intervalId);
    const CHS=['kick','snare','clap','hihat','openhat','perc'];
    CHS.forEach(ch=>{ for(let i=0;i<16;i++) document.getElementById(`${id}-step-${ch}-${i}`)?.classList.remove('playing'); });
    const btn=document.getElementById(`${id}-dm-btn`);
    if(btn){btn.textContent='‚ñ∂ PLAY';btn.classList.remove('running');}
    if(nodes[id]) nodes[id].params.playing=false;
  });
  dmState={};
  Object.values(audioNodes).forEach(an=>{
    try{if(an.osc)an.osc.stop();else if(an.main?.stop)an.main.stop();}catch(e){}
    try{if(an.main?.disconnect)an.main.disconnect();}catch(e){}
  });
  audioCtx.close(); audioCtx=null; audioNodes={}; masterGain=null;
  scopeHistory={};
  // Clear scopes
  document.querySelectorAll('.scope-canvas').forEach(c=>{
    const ctx=c.getContext('2d'); ctx.fillStyle='#000810'; ctx.fillRect(0,0,c.width,c.height);
  });
  document.querySelectorAll('.vu-fill').forEach(el=>el.style.width='0%');
  Object.keys(nodes).forEach(id=>document.getElementById(id)?.classList.remove('running'));
  document.getElementById('play-btn').style.display='inline-block';
  document.getElementById('stop-btn').style.display='none';
  document.getElementById('status-msg').textContent='';
}

// ‚îÄ‚îÄ‚îÄ Presets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loadPreset(name){
  if(!name) return;
  // User-saved preset
  if (name.startsWith('user:')) {
    const key = name.slice(5);
    const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
    if (saved[key]) { loadUserPreset(saved[key]); setActivePreset(key); }
    return;
  }
  setActivePreset(null);
  clearAll();
  switch(name){

    case'drone': {
      // Simple hypnotic drone ‚Äî detuned oscillators + filter sweep
      const o1 = createNode('oscillator', 60, 80, {freq:110,wave:'sawtooth'});
      const o2 = createNode('oscillator', 60,230, {freq:110.5,wave:'sawtooth'});
      const g1 = createNode('gain', 290,100, {gain:0.4});
      const g2 = createNode('gain', 290,230, {gain:0.4});
      const flt= createNode('filter', 500,160, {type:'lowpass',freq:600,q:3});
      const lfo= createNode('lfo',   500,320, {freq:0.2,depth:400});
      const spk= createNode('speaker',720,160);
      const scp= createNode('oscilloscope',720,280);
      setTimeout(()=>{
        addEdge(o1,'signal',g1,'signal'); addEdge(o2,'signal',g2,'signal');
        addEdge(g1,'signal',flt,'signal'); addEdge(g2,'signal',flt,'signal');
        addEdge(flt,'signal',spk,'signal'); addEdge(flt,'signal',scp,'signal');
        addEdge(lfo,'mod',flt,'freq_mod');
        renderEdges();
      },50); break;
    }

    case'wobble': {
      // Classic acid bass ‚Äî square wave through resonant filter, fast LFO
      const osc = createNode('oscillator', 60,100, {freq:80,wave:'square'});
      const flt = createNode('filter',     290,80, {type:'lowpass',freq:300,q:8});
      const dis = createNode('distortion', 500,80, {amount:30});
      const gain= createNode('gain',       700,80, {gain:0.5});
      const lfo = createNode('lfo',        290,270,{freq:1.5,depth:600});
      const spk = createNode('speaker',    700,220);
      const scp = createNode('oscilloscope',700,360);
      setTimeout(()=>{
        addEdge(osc,'signal',flt,'signal'); addEdge(flt,'signal',dis,'signal');
        addEdge(dis,'signal',gain,'signal'); addEdge(gain,'signal',spk,'signal');
        addEdge(gain,'signal',scp,'signal'); addEdge(lfo,'mod',flt,'freq_mod');
        renderEdges();
      },50); break;
    }

    case'space': {
      // Spacious ambient ‚Äî sine through long delay + reverb + scope
      const osc = createNode('oscillator', 60,120, {freq:220,wave:'sine'});
      const g1  = createNode('gain',       270,120,{gain:0.7});
      const del = createNode('delay',      460,80, {time:0.6,feedback:0.65});
      const rev = createNode('reverb',     460,240,{duration:4,decay:3,wet:0.6});
      const g2  = createNode('gain',       680,160,{gain:0.35});
      const lfo = createNode('lfo',        60, 290,{freq:0.15,depth:30});
      const spk = createNode('speaker',    680,300);
      const scp = createNode('oscilloscope',460,400);
      setTimeout(()=>{
        addEdge(osc,'signal',g1,'signal'); addEdge(g1,'signal',del,'signal');
        addEdge(del,'signal',rev,'signal'); addEdge(rev,'signal',g2,'signal');
        addEdge(g2,'signal',spk,'signal'); addEdge(g2,'signal',scp,'signal');
        addEdge(lfo,'mod',osc,'freq_mod');
        renderEdges();
      },50); break;
    }

    case'fuzz': {
      // Fuzz lead ‚Äî sawtooth with fast LFO on filter + heavy distortion + compression
      const osc = createNode('oscillator', 60, 80, {freq:220,wave:'sawtooth'});
      const flt = createNode('filter',     280, 60,{type:'lowpass',freq:2000,q:3});
      const dis = createNode('distortion', 490, 60,{amount:180});
      const cmp = createNode('compressor', 700, 60,{threshold:-24,ratio:8,knee:6});
      const gain= createNode('gain',       700,210,{gain:0.45});
      const lfo = createNode('lfo',        280,240,{freq:5,depth:1800});
      const spk = createNode('speaker',    700,340);
      const scp = createNode('oscilloscope',490,260);
      setTimeout(()=>{
        addEdge(osc,'signal',flt,'signal'); addEdge(flt,'signal',dis,'signal');
        addEdge(dis,'signal',cmp,'signal'); addEdge(cmp,'signal',gain,'signal');
        addEdge(gain,'signal',spk,'signal'); addEdge(dis,'signal',scp,'signal');
        addEdge(lfo,'mod',flt,'freq_mod');
        renderEdges();
      },50); break;
    }

    case'arpseq': {
      // Step sequencer ‚Üí square osc ‚Üí filter ‚Üí delay ‚Üí gain ‚Üí speaker + scope
      // seq ‚Üí osc ‚Üí filter ‚Üí delay ‚Üí speaker;  filter also ‚Üí scope
      const seq = createNode('sequencer',  30,  30, {bpm:140});
      const osc = createNode('oscillator', 340,  30, {freq:220, wave:'square'});
      const flt = createNode('filter',     560,  30, {type:'lowpass', freq:800, q:6});
      const del = createNode('delay',      560, 220, {time:0.21, feedback:0.35});
      const spk = createNode('speaker',    780, 100);
      const scp = createNode('oscilloscope', 780, 260);
      setTimeout(()=>{
        addEdge(seq,'freq',  osc,'freq');
        addEdge(osc,'signal', flt,'signal');
        addEdge(flt,'signal', del,'signal');
        addEdge(del,'signal', spk,'signal');
        addEdge(flt,'signal', scp,'signal');
        renderEdges();
      },50); break;
    }

    case'stereopan': {
      // Two detuned oscillators panned hard L/R ‚Äî classic stereo widening
      // Osc A (sine 220Hz) ‚Üí Pan L ‚Üí Speaker
      // Osc B (triangle 329Hz) ‚Üí Pan R ‚Üí Speaker
      // LFO gently drifts Pan A for slow movement
      // Stereo scope: L ‚Üê Pan A, R ‚Üê Pan B
      const oscA  = createNode('oscillator',  60,  60, {freq:220, wave:'sine'});
      const panA  = createNode('pan',         280,  60, {pan:-0.75});
      const oscB  = createNode('oscillator',  60, 230, {freq:329.6, wave:'triangle'});
      const panB  = createNode('pan',         280, 230, {pan:0.75});
      const lfo   = createNode('lfo',         60,  400, {freq:0.2, depth:0.4});
      const spk   = createNode('speaker',     500, 145);
      const scp   = createNode('stereo_scope',500, 300, {mode:'phosphor'});
      setTimeout(()=>{
        addEdge(oscA,'signal', panA,'signal');
        addEdge(oscB,'signal', panB,'signal');
        addEdge(panA,'signal', spk,'signal');
        addEdge(panB,'signal', spk,'signal');
        addEdge(panA,'signal', scp,'L');
        addEdge(panB,'signal', scp,'R');
        addEdge(lfo,'mod',     panA,'pan_mod'); // LFO drifts pan A slowly
        renderEdges();
      },50); break;
    }

    case'pingpong': {
      // Sawtooth through ping-pong delay ‚Äî classic stereo bounce effect
      // Dry signal + bounced echoes alternate L and R
      const osc  = createNode('oscillator',  60, 100, {freq:220, wave:'sawtooth'});
      const gain = createNode('gain',        260, 100, {gain:0.6});
      const pp   = createNode('ping_pong',   460,  60, {timeL:0.3, timeR:0.6, feedback:0.45, wet:0.6});
      const spk  = createNode('speaker',     700, 100);
      const lfo  = createNode('lfo',         60,  280, {freq:0.08, depth:40});
      const scp  = createNode('stereo_scope',700, 260, {mode:'phosphor'});
      setTimeout(()=>{
        addEdge(osc,'signal',  gain,'signal');
        addEdge(gain,'signal', pp,'signal');
        addEdge(pp,'signal',   spk,'signal');
        addEdge(pp,'signal',   scp,'L');
        addEdge(pp,'signal',   scp,'R');
        addEdge(lfo,'mod',     osc,'freq_mod');
        renderEdges();
      },50); break;
    }

    case'keyjam': {
      // Keyboard ‚Üí sawtooth ‚Üí filter ‚Üí reverb ‚Üí speaker
      // Play notes with mouse clicks or QWERTY keys
      const kb   = createNode('keyboard',    30,  80);
      const osc  = createNode('oscillator',  280,  80, {freq:261.6, wave:'sawtooth'});
      const flt  = createNode('filter',      490,  80, {type:'lowpass', freq:1200, q:4});
      const rev  = createNode('reverb',      490, 250, {duration:2, decay:1.5, wet:0.35});
      const spk  = createNode('speaker',     700, 165);
      const scp  = createNode('oscilloscope',700, 310, {mode:'phosphor'});
      setTimeout(()=>{
        addEdge(kb,'freq',    osc,'freq');
        addEdge(osc,'signal', flt,'signal');
        addEdge(flt,'signal', rev,'signal');
        addEdge(rev,'signal', spk,'signal');
        addEdge(flt,'signal', scp,'signal');
        renderEdges();
      },50); break;
    }

    case'envdemo': {
      // Envelope ADSR demo ‚Äî keyboard gates an ADSR amp envelope
      // Chain: KB freq‚ÜíOSC  KB gate‚ÜíENV  OSC‚ÜíENV‚Üífilter‚Üíreverb‚Üíspeaker
      // The envelope shapes the volume of each note: attack/decay/sustain/release
      // Try: short attack (punchy), long release (pad-like), sustain=0 (pluck)
      const kb  = createNode('keyboard',   30,  90);
      const osc = createNode('oscillator', 270,  90, {freq:261.6, wave:'triangle'});
      const env = createNode('envelope',   500,  90, {attack:0.02, decay:0.12, sustain:0.65, release:0.55});
      const flt = createNode('filter',     730,  90, {type:'lowpass', freq:2200, q:2});
      const rev = createNode('reverb',     730, 270, {duration:1.5, decay:1.0, wet:0.25});
      const spk = createNode('speaker',    940, 175);
      const scp = createNode('oscilloscope',940, 320, {mode:'phosphor'});
      setTimeout(()=>{
        addEdge(kb, 'freq',   osc,'freq');    // keyboard sets pitch
        addEdge(kb, 'gate',   env,'gate');    // keyboard gates envelope (amber dashed wire)
        addEdge(osc,'signal', env,'signal');  // osc audio passes through envelope
        addEdge(env,'signal', flt,'signal');
        addEdge(flt,'signal', rev,'signal');
        addEdge(rev,'signal', spk,'signal');
        addEdge(env,'signal', scp,'signal');  // scope shows envelope-shaped waveform
        renderEdges();
      },50); break;
    }

    case'drum_loop': {
      // Kick: 1,5,9,13 | Snare: 5,13 | Closed HH: every even step | Open HH: 7,15
      const dm  = createNode('drum_machine', 30, 60, {
        bpm: 120,
        kick_steps:    [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
        snare_steps:   [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
        clap_steps:    [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
        hihat_steps:   [0,1,0,1, 0,1,0,1, 0,1,0,1, 0,1,0,1],
        openhat_steps: [0,0,0,0, 0,0,1,0, 0,0,0,0, 0,0,1,0],
        perc_steps:    [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
        kick_vol:0.95, snare_vol:0.85, hihat_vol:0.65, openhat_vol:0.6,
      });
      const cmp = createNode('compressor', 600, 80, {threshold:-18, ratio:4, knee:6});
      const spk = createNode('speaker',    820, 80);
      setTimeout(()=>{
        addEdge(dm, 'mix_out', cmp,'signal');
        addEdge(cmp,'signal',  spk,'signal');
        renderEdges();
      },50); break;
    }
  }
}

// ‚îÄ‚îÄ‚îÄ Auto Arrange ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function autoArrange() {
  const ids = Object.keys(nodes);
  if (!ids.length) return;

  // ‚îÄ‚îÄ Phase 1: Longest-path depth (column) assignment ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const depth = {};
  ids.forEach(id => depth[id] = 0);
  for (let pass = 0; pass < ids.length; pass++) {
    edges.forEach(e => {
      if (nodes[e.srcNode] && nodes[e.dstNode]) {
        const d = (depth[e.srcNode] || 0) + 1;
        if (d > depth[e.dstNode]) depth[e.dstNode] = d;
      }
    });
  }

  // Group by column
  const cols = {};
  ids.forEach(id => {
    const d = depth[id] || 0;
    if (!cols[d]) cols[d] = [];
    cols[d].push(id);
  });
  const colKeys = Object.keys(cols).sort((a,b) => +a - +b);

  // Measure nodes
  const nW = {}, nH = {};
  ids.forEach(id => {
    const el = document.getElementById(id);
    nW[id] = el ? el.offsetWidth  : 190;
    nH[id] = el ? el.offsetHeight : 140;
  });

  // ‚îÄ‚îÄ Phase 2: Seed initial positions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const COL_STRIDE = 260, ROW_STRIDE = 170, PAD = 40;
  const colMaxW = {};
  colKeys.forEach(col => colMaxW[col] = Math.max(...cols[col].map(id => nW[id])));

  // Build column x positions
  const colX = {};
  let cx = PAD;
  colKeys.forEach(col => { colX[col] = cx; cx += colMaxW[col] + Math.max(60, COL_STRIDE - colMaxW[col]); });

  const pos = {};
  const vel = {};
  colKeys.forEach(col => {
    const list = cols[col];
    const totalH = list.reduce((s, id) => s + nH[id], 0) + (list.length - 1) * 20;
    let y = PAD + Math.max(0, 300 - totalH / 2); // center-ish vertically
    list.forEach(id => {
      pos[id] = { x: colX[col], y };
      vel[id] = { x: 0, y: 0 };
      y += nH[id] + 20;
    });
  });

  // ‚îÄ‚îÄ Phase 3: Force-directed physics (CPU-only, ~100 iters) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const REPULSION   = 15000;
  const SPRING_K    = 0.04;
  const SPRING_REST = 280;
  const COL_ANCHOR  = 0.5;   // pull toward column x
  const DAMPING     = 0.80;
  const DT          = 0.9;

  for (let iter = 0; iter < 120; iter++) {
    const force = {};
    ids.forEach(id => force[id] = { x: 0, y: 0 });

    // Node-node repulsion (Y-dominant: same-column nodes push vertically)
    for (let i = 0; i < ids.length; i++) {
      for (let j = i + 1; j < ids.length; j++) {
        const a = ids[i], b = ids[j];
        const dx = pos[b].x - pos[a].x;
        const dy = pos[b].y - pos[a].y;
        // Use bounding-box repulsion: account for node sizes
        const overlapX = Math.max(0, (nW[a] + nW[b]) / 2 + 20 - Math.abs(dx));
        const overlapY = Math.max(0, (nH[a] + nH[b]) / 2 + 20 - Math.abs(dy));
        const dist2 = Math.max(dx*dx + dy*dy, 100);
        const dist  = Math.sqrt(dist2);
        // Pure distance repulsion
        const f = REPULSION / dist2;
        const nx = dx / dist, ny = dy / dist;
        force[a].x -= f * nx * 0.3;  // weaker X repulsion (columns handle x)
        force[a].y -= f * ny;
        force[b].x += f * nx * 0.3;
        force[b].y += f * ny;
        // Extra overlap push
        if (overlapX > 0 && overlapY > 0) {
          const push = 4;
          force[a].y -= (dy < 0 ? -push : push);
          force[b].y += (dy < 0 ? -push : push);
        }
      }
    }

    // Edge springs
    edges.forEach(e => {
      if (!pos[e.srcNode] || !pos[e.dstNode]) return;
      const a = e.srcNode, b = e.dstNode;
      const dx = pos[b].x - pos[a].x;
      const dy = pos[b].y - pos[a].y;
      const dist = Math.max(Math.sqrt(dx*dx + dy*dy), 1);
      const f = SPRING_K * (dist - SPRING_REST);
      const nx = dx/dist, ny = dy/dist;
      // Springs only pull vertically (not x ‚Äî columns handle that)
      force[a].y += f * ny;
      force[b].y -= f * ny;
    });

    // Column x anchor (keep nodes in their assigned column)
    ids.forEach(id => {
      const d = depth[id] || 0;
      const targetX = colX[String(d)];
      force[id].x += COL_ANCHOR * (targetX - pos[id].x);
    });

    // Integrate
    ids.forEach(id => {
      vel[id].x = (vel[id].x + force[id].x * DT * 0.01) * DAMPING;
      vel[id].y = (vel[id].y + force[id].y * DT * 0.01) * DAMPING;
      pos[id].x = Math.max(0, pos[id].x + vel[id].x);
      pos[id].y = Math.max(0, pos[id].y + vel[id].y);
    });
  }

  // ‚îÄ‚îÄ Phase 4: Animate nodes to final positions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const EASE = 'cubic-bezier(0.34, 1.56, 0.64, 1)';  // spring bounce
  ids.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    const snap24 = v => Math.round(v / 24) * 24; // align to dot grid
    const fx = snap24(pos[id].x), fy = snap24(pos[id].y);
    el.style.transition = `left 0.55s ${EASE}, top 0.55s ${EASE}`;
    el.style.left = fx + 'px';
    el.style.top  = fy + 'px';
    nodes[id].x = fx;
    nodes[id].y = fy;
  });

  // Remove transitions after animation
  setTimeout(() => {
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.transition = '';
    });
    renderEdges();
  }, 620);

  // Fit viewport
  const maxX = Math.max(...ids.map(id => pos[id].x + nW[id])) + PAD;
  const maxY = Math.max(...ids.map(id => pos[id].y + nH[id])) + PAD;
  const canvasW = canvasEl.clientWidth || 900;
  const canvasH = canvasEl.clientHeight || 600;
  canvasScale = Math.min(1, canvasW / maxX, canvasH / maxY);
  canvasOffset = { x: 0, y: 0 };
  applyCanvasTransform();
}

function applyCanvasTransform() {
  // Apply combined translate+scale transform
  const tx = canvasOffset.x * canvasScale;
  const ty = canvasOffset.y * canvasScale;
  canvasEl.style.transform = `translate(${tx.toFixed(1)}px, ${ty.toFixed(1)}px) scale(${canvasScale.toFixed(4)})`;
  
  // Update zoom display
  const zoomEl = document.getElementById('stat-zoom');
  if (zoomEl) zoomEl.textContent = Math.round(canvasScale * 100) + '%';
}

function resetCanvasScale() {
  canvasScale = 1.0;
  canvasOffset = {x:0, y:0};
  applyCanvasTransform();
}

// ‚îÄ‚îÄ‚îÄ User Presets (localStorage) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const STORAGE_KEY = 'synth-user-presets';
let activeUserPreset = null;

function setActivePreset(name) {
  activeUserPreset = name || null;
  const isUser = !!activeUserPreset;
  const del = document.getElementById('btn-delete');
  if (del) { del.disabled = !isUser; del.style.opacity = isUser ? '1' : '0.4'; }
}

function serializeGraph() {
  return {
    nodes: Object.values(nodes).map(n => ({
      id: n.id, type: n.type, x: n.x, y: n.y,
      params: JSON.parse(JSON.stringify(n.params))
    })),
    edges: edges.map(e => ({ ...e }))
  };
}

function persistPreset(key) {
  const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
  saved[key] = { name: key, ...serializeGraph() };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
}

function savePreset() {
  const name = prompt('Save preset:', activeUserPreset || '');
  if (!name || !name.trim()) return;
  const key = name.trim();
  const isOverwrite = key === activeUserPreset;
  persistPreset(key);
  addUserPresetOption(key);
  setActivePreset(key);
  const msg = isOverwrite ? `‚úì updated "${key}"` : `‚úì saved "${key}"`;
  document.getElementById('status-msg').textContent = msg;
  setTimeout(() => document.getElementById('status-msg').textContent = '', 2000);
}

function deleteCurrentPreset() {
  if (!activeUserPreset) return;
  if (!confirm(`Delete preset "${activeUserPreset}"?`)) return;
  const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
  delete saved[activeUserPreset];
  localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
  // Remove from dropdown
  const group = document.getElementById('user-preset-group');
  group.querySelector(`option[value="user:${activeUserPreset}"]`)?.remove();
  setActivePreset(null);
  document.getElementById('status-msg').textContent = `Deleted`;
  setTimeout(() => document.getElementById('status-msg').textContent = '', 2000);
}

function addUserPresetOption(name) {
  const group = document.getElementById('user-preset-group');
  if (group.querySelector(`option[value="user:${name}"]`)) return;
  const opt = document.createElement('option');
  opt.value = 'user:' + name;
  opt.textContent = name;
  group.appendChild(opt);
}

function loadUserPreset(data) {
  clearAll();
  const idMap = {};
  // Restore nodes with original positions
  data.nodes.forEach(n => {
    const newId = createNode(n.type, n.x, n.y, n.params);
    idMap[n.id] = newId;
  });
  setTimeout(() => {
    data.edges.forEach(e => {
      const src = idMap[e.srcNode], dst = idMap[e.dstNode];
      if (src && dst) addEdge(src, e.srcPort, dst, e.dstPort);
    });
    renderEdges();
  }, 50);
}

function populateUserPresets() {
  const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
  Object.keys(saved).forEach(name => addUserPresetOption(name));
}

// ‚îÄ‚îÄ‚îÄ Utility ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateStats(){
  document.getElementById('stat-nodes').textContent=Object.keys(nodes).length;
  document.getElementById('stat-edges').textContent=edges.length;
}
function clearAll(){
  stopAudio();
  Object.keys(nodes).forEach(id=>document.getElementById(id)?.remove());
  nodes={}; edges=[]; nodeIdCounter=0;
  setActivePreset(null);
  resetCanvasScale();
  renderEdges(); updateStats();
}

// ‚îÄ‚îÄ‚îÄ Scroll-to-adjust number inputs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.addEventListener('wheel', e => {
  const el = e.target;
  if (el.tagName !== 'INPUT' || el.type !== 'number') return;
  e.preventDefault();
  const step = parseFloat(el.step) || 1;
  const min  = el.min !== '' ? parseFloat(el.min)  : -Infinity;
  const max  = el.max !== '' ? parseFloat(el.max)  :  Infinity;
  const dir  = e.deltaY < 0 ? 1 : -1;
  const newVal = Math.min(max, Math.max(min, parseFloat(el.value) + step * dir));
  // round to same decimal places as step to avoid float noise
  const decimals = (step.toString().split('.')[1] || '').length;
  el.value = newVal.toFixed(decimals);
  el.dispatchEvent(new Event('change', { bubbles: true }));
}, { passive: false });

// ‚îÄ‚îÄ‚îÄ Perf Monitor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(function perfLoop() {
  const canvas = document.getElementById('perf-canvas');
  const ctx2   = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const history = new Array(W).fill(0);
  let lastT = performance.now(), frameCount = 0, fps = 0;
  const hasHeap = !!(performance.memory);
  if (hasHeap) document.getElementById('perf-heap-row').style.display = 'flex';

  function tick(now) {
    requestAnimationFrame(tick);
    frameCount++;
    const elapsed = now - lastT;
    if (elapsed >= 500) {
      fps = Math.round(frameCount / elapsed * 1000);
      frameCount = 0; lastT = now;
      document.getElementById('perf-fps').textContent = fps;
      if (hasHeap) {
        const mb = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
        document.getElementById('perf-heap').textContent = mb + ' MB';
      }
    }
    // sparkline: fps normalised 0‚Äì60
    history.push(Math.min(fps, 60));
    if (history.length > W) history.shift();

    ctx2.clearRect(0, 0, W, H);
    // grid line at 30fps
    ctx2.strokeStyle = 'rgba(48,54,61,0.8)'; ctx2.lineWidth = 0.5;
    ctx2.beginPath(); ctx2.moveTo(0, H/2); ctx2.lineTo(W, H/2); ctx2.stroke();

    // sparkline
    ctx2.beginPath();
    ctx2.strokeStyle = fps >= 55 ? '#58d68d' : fps >= 30 ? '#d6a058' : '#f85149';
    ctx2.lineWidth = 1.5;
    history.forEach((v, i) => {
      const x = i, y = H - (v / 60) * (H - 2) - 1;
      i === 0 ? ctx2.moveTo(x, y) : ctx2.lineTo(x, y);
    });
    ctx2.stroke();

    // fill under line
    ctx2.lineTo(W, H); ctx2.lineTo(0, H); ctx2.closePath();
    ctx2.fillStyle = fps >= 55 ? 'rgba(88,214,141,0.08)' : fps >= 30 ? 'rgba(214,160,88,0.08)' : 'rgba(248,81,73,0.08)';
    ctx2.fill();
  }
  requestAnimationFrame(tick);
})();

// ‚îÄ‚îÄ‚îÄ Drag-to-change number inputs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
{
  let dragInput=null, dragStartY=0, dragStartVal=0;
  document.addEventListener('mousedown', e=>{
    const inp=e.target.closest('input.param-input[type="number"]');
    if(!inp || e.detail===2) return; // double-click = allow text edit
    e.preventDefault();
    dragInput=inp; dragStartY=e.clientY;
    dragStartVal=parseFloat(inp.value)||0;
    inp.blur();
  });
  document.addEventListener('mousemove', e=>{
    if(!dragInput) return;
    const step=parseFloat(dragInput.step)||1;
    const min=dragInput.min!==''?parseFloat(dragInput.min):-Infinity;
    const max=dragInput.max!==''?parseFloat(dragInput.max):Infinity;
    const sensitivity=e.shiftKey?step*0.1:step; // shift = fine control
    const delta=(dragStartY-e.clientY)*sensitivity*0.5;
    const decimals=step<1?String(step).split('.')[1]?.length||2:0;
    const newVal=Math.min(max,Math.max(min,parseFloat((dragStartVal+delta).toFixed(decimals))));
    dragInput.value=newVal;
    dragInput.dispatchEvent(new Event('change',{bubbles:true}));
    dragInput.dispatchEvent(new Event('input',{bubbles:true}));
  });
  document.addEventListener('mouseup', ()=>{ dragInput=null; });
  // Double-click ‚Üí select all for typing
  document.addEventListener('dblclick', e=>{
    const inp=e.target.closest('input.param-input[type="number"]');
    if(inp){ inp.focus(); inp.select(); }
  });
}

// ‚îÄ‚îÄ‚îÄ Help Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const HELP_SEEN_KEY='synth_html_help_seen';
function toggleHelp(){
  const el=document.getElementById('help-overlay');
  const shown=el.style.display==='flex';
  el.style.display=shown?'none':'flex';
  if(!shown) localStorage.setItem(HELP_SEEN_KEY,'1');
}
function closeHelp(){
  document.getElementById('help-overlay').style.display='none';
  localStorage.setItem(HELP_SEEN_KEY,'1');
}
document.addEventListener('keydown',e=>{
  if(e.key==='Escape'){ closeHelp(); closeShareModal(); }
});
document.getElementById('help-overlay').addEventListener('click',e=>{
  if(e.target===e.currentTarget) closeHelp();
});

// ‚îÄ‚îÄ‚îÄ Share / URL encoding ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _shareUrl = '';

const _adjectives = ['amber','violet','cosmic','frozen','liquid','electric','fuzzy','warped','hollow','silky','dusty','glassy','muted','radiant','smoky','velvet','distant','drifting','droning','pulsing'];
const _nouns      = ['drift','nebula','chorus','cascade','shimmer','static','current','echo','surge','void','bloom','wave','fog','prism','oscillation','pulse','resonance','signal','tone','flux'];
function randomPatchName() {
  const a = _adjectives[Math.floor(Math.random() * _adjectives.length)];
  const n = _nouns[Math.floor(Math.random() * _nouns.length)];
  return a + ' ' + n;
}

function shareLink() {
  const graph = serializeGraph();
  // Use saved preset name if active; otherwise generate a random one ‚Äî no prompt
  const name = activeUserPreset || randomPatchName();
  const payload = { name, ...graph };
  const encoded = btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
  const url = location.href.split('#')[0] + '#patch=' + encoded;
  _shareUrl = url;

  // Auto-copy to clipboard
  const tryClipboard = navigator.clipboard?.writeText?.(url);
  if (tryClipboard) {
    tryClipboard.catch(() => copyFallback(url));
  } else {
    try {
      const ta = document.createElement('textarea');
      ta.value = url; ta.style.cssText='position:fixed;opacity:0';
      document.body.appendChild(ta); ta.focus(); ta.select();
      document.execCommand('copy'); ta.remove();
    } catch(e) {}
  }

  // Show share modal
  document.getElementById('share-url-input').value = url;
  document.getElementById('share-patch-name').textContent = name.trim() ? `"${name.trim()}"` : 'untitled patch';
  document.getElementById('share-copy-btn').textContent = 'Copy';
  document.getElementById('share-copy-btn').style.borderColor = '#58d68d';
  document.getElementById('share-copy-btn').style.color = '#58d68d';
  const overlay = document.getElementById('share-overlay');
  overlay.style.display = 'flex';
  requestAnimationFrame(() => {
    document.getElementById('share-url-input').select();
  });
}

function copyShareUrl() {
  const inp = document.getElementById('share-url-input');
  const btn = document.getElementById('share-copy-btn');
  const tryClip = navigator.clipboard?.writeText?.(_shareUrl);
  const onOk = () => {
    btn.textContent = '‚úì Copied!'; btn.style.borderColor='#3fb950'; btn.style.color='#3fb950';
    setTimeout(() => { btn.textContent='Copy'; btn.style.borderColor='#58d68d'; btn.style.color='#58d68d'; }, 2000);
  };
  if (tryClip) { tryClip.then(onOk).catch(() => { inp.select(); document.execCommand('copy'); onOk(); }); }
  else { inp.select(); try { document.execCommand('copy'); onOk(); } catch(e) {} }
}

function closeShareModal() {
  document.getElementById('share-overlay').style.display = 'none';
}

// Close on backdrop click
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('share-overlay').addEventListener('click', e => {
    if (e.target === e.currentTarget) closeShareModal();
  });
});

// copyFallback removed ‚Äî inlined into shareLink/copyShareUrl

function loadFromHash() {
  const hash = location.hash;
  if (!hash.startsWith('#patch=')) return;
  try {
    const encoded = hash.slice(7);
    const payload = JSON.parse(decodeURIComponent(escape(atob(encoded))));
    const { name, nodes: ns, edges: es } = payload;
    loadUserPreset({ nodes: ns, edges: es });
    if (name) {
      document.getElementById('status-msg').textContent = `‚Üó loaded "${name}"`;
      setTimeout(() => document.getElementById('status-msg').textContent = '', 3000);
    }
    // stash name so Save can use it
    if (name) setActivePreset(name);
  } catch(e) {
    console.warn('Failed to load patch from URL:', e);
  }
}

// ‚îÄ‚îÄ‚îÄ Canvas zoom & pan ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let spaceHeld = false;

// Zoom with Ctrl+wheel (or Cmd+wheel on Mac) ‚Äî zoom around cursor
canvasEl.addEventListener('wheel', e => {
  // Only zoom if Ctrl/Cmd held, otherwise let default scroll happen
  if (!e.ctrlKey && !e.metaKey) return;
  e.preventDefault();
  e.stopPropagation();
  
  const cr = canvasEl.getBoundingClientRect();
  // Mouse position in screen space relative to canvas
  const mx = e.clientX - cr.left;
  const my = e.clientY - cr.top;
  // Mouse position in canvas space (before zoom)
  const cx = (mx / canvasScale) - canvasOffset.x;
  const cy = (my / canvasScale) - canvasOffset.y;
  
  // Calculate new scale
  const zoomFactor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
  const newScale = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, canvasScale * zoomFactor));
  
  // Adjust offset so the point under cursor stays fixed
  canvasOffset.x = (mx / newScale) - cx;
  canvasOffset.y = (my / newScale) - cy;
  canvasScale = newScale;
  
  applyCanvasTransform();
  renderEdges();
}, { passive: false });

// Pan with middle mouse button OR space+drag
canvasEl.addEventListener('mousedown', e => {
  // Middle button (1) or left button with space held
  if (e.button === 1 || (e.button === 0 && spaceHeld)) {
    e.preventDefault();
    isPanning = true;
    panStart = { x: e.clientX, y: e.clientY };
    panStartOffset = { x: canvasOffset.x, y: canvasOffset.y };
    canvasEl.classList.add('panning');
  }
});

document.addEventListener('mousemove', e => {
  if (!isPanning) return;
  const dx = (e.clientX - panStart.x) / canvasScale;
  const dy = (e.clientY - panStart.y) / canvasScale;
  canvasOffset.x = panStartOffset.x + dx;
  canvasOffset.y = panStartOffset.y + dy;
  applyCanvasTransform();
  renderEdges();
});

document.addEventListener('mouseup', e => {
  if (isPanning && (e.button === 1 || e.button === 0)) {
    isPanning = false;
    canvasEl.classList.remove('panning');
  }
});

// Space key to enable panning mode
document.addEventListener('keydown', e => {
  if (e.code === 'Space' && !e.repeat && e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT') {
    spaceHeld = true;
    canvasEl.classList.add('panning');
    e.preventDefault();
  }
  // Home key to reset view
  if (e.code === 'Home') {
    resetCanvasScale();
    renderEdges();
  }
});

document.addEventListener('keyup', e => {
  if (e.code === 'Space') {
    spaceHeld = false;
    if (!isPanning) canvasEl.classList.remove('panning');
  }
});

// Double-click on empty canvas to reset view
canvasEl.addEventListener('dblclick', e => {
  if (e.target === canvasEl || e.target === svgLayer) {
    resetCanvasScale();
    renderEdges();
  }
});

// ‚îÄ‚îÄ‚îÄ QWERTY keyboard ‚Üí keyboard node ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const QWERTY_MAP = {
  'a':0,'w':1,'s':2,'e':3,'d':4,'f':5,'t':6,'g':7,'y':8,'h':9,'u':10,'j':11,'k':12
};
document.addEventListener('keydown', e => {
  if (e.repeat || e.target.tagName==='INPUT' || e.target.tagName==='SELECT') return;
  if (e.key === '-') {
    if (activeKbNode && nodes[activeKbNode]) {
      nodes[activeKbNode].params.octave = Math.max(1, +nodes[activeKbNode].params.octave - 1);
      updateParam(activeKbNode,'octave',nodes[activeKbNode].params.octave);
    }
    return;
  }
  if (e.key === '=') {
    if (activeKbNode && nodes[activeKbNode]) {
      nodes[activeKbNode].params.octave = Math.min(7, +nodes[activeKbNode].params.octave + 1);
      updateParam(activeKbNode,'octave',nodes[activeKbNode].params.octave);
    }
    return;
  }
  const semi = QWERTY_MAP[e.key.toLowerCase()];
  if (semi === undefined) return;
  if (!activeKbNode) {
    const kbn = Object.values(nodes).find(n => n.type==='keyboard');
    if (kbn) activeKbNode = kbn.id;
  }
  if (activeKbNode) kbPress(activeKbNode, semi);
});
document.addEventListener('keyup', e => {
  const semi = QWERTY_MAP[e.key.toLowerCase()];
  if (semi !== undefined && activeKbNode) kbRelease(activeKbNode, semi);
  // Also handle non-note keys that might leave envelopes hanging
});

// ‚îÄ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
populateUserPresets();
// Load from URL hash first; fall back to default preset
if (location.hash.startsWith('#patch=')) {
  loadFromHash();
} else {
  loadPreset('wobble');
}
// Show help on first ever visit
if(!localStorage.getItem(HELP_SEEN_KEY)){
  setTimeout(()=>{ document.getElementById('help-overlay').style.display='flex'; }, 400);
}
</script>
</body>
</html>
