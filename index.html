<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>synth.html</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: #0f1117; color: #e0e0e0;
    font-family: 'IBM Plex Mono', 'Fira Code', monospace;
    font-size: 12px; overflow: hidden; height: 100vh;
  }
  #toolbar {
    position: fixed; top: 0; left: 0; right: 0; height: 44px;
    background: #161b22; border-bottom: 1px solid #30363d;
    display: flex; align-items: center; padding: 0 16px; gap: 8px; z-index: 100;
  }
  .logo { font-size: 14px; font-weight: 700; color: #c97bff; letter-spacing: 1px; margin-right: 16px; }
  .tb-btn {
    background: #21262d; border: 1px solid #30363d; color: #c9d1d9;
    padding: 4px 14px; border-radius: 4px; cursor: pointer;
    font-family: inherit; font-size: 11px; transition: all 0.15s;
  }
  .tb-btn:hover { background: #30363d; }
  .tb-btn.play { border-color: #58d68d; color: #58d68d; }
  .tb-btn.play:hover { background: #58d68d22; }
  .tb-btn.stop { border-color: #f85149; color: #f85149; display: none; }
  .tb-btn.stop:hover { background: #f8514922; }
  .tb-select {
    background: #21262d; border: 1px solid #30363d; color: #c9d1d9;
    padding: 4px 8px; border-radius: 4px; font-family: inherit; font-size: 11px;
    cursor: pointer; outline: none;
  }
  .tb-sep { width: 1px; height: 24px; background: #30363d; margin: 0 4px; }
  #node-palette {
    position: fixed; top: 44px; left: 0; width: 180px; bottom: 0;
    background: #161b22; border-right: 1px solid #30363d;
    padding: 12px 8px 110px; overflow-y: auto; z-index: 50;
  }
  .palette-section { margin-bottom: 16px; }
  .palette-label { font-size: 9px; letter-spacing: 2px; text-transform: uppercase; color: #484f58; margin-bottom: 8px; padding: 0 4px; }
  .palette-item {
    background: #21262d; border: 1px solid #30363d; border-left: 3px solid;
    border-radius: 4px; padding: 8px 10px; margin-bottom: 4px;
    cursor: grab; transition: all 0.15s; user-select: none;
  }
  .palette-item:hover { background: #2d333b; transform: translateX(2px); }
  .palette-item .item-name { font-size: 11px; color: #c9d1d9; }
  .palette-item .item-desc { font-size: 9px; color: #484f58; margin-top: 2px; }
  .pi-source { border-left-color: #58d68d; }
  .pi-effect { border-left-color: #5da0d0; }
  .pi-mod    { border-left-color: #d6a058; }
  .pi-sink   { border-left-color: #c97bff; }
  #canvas-area {
    position: fixed; top: 44px; left: 180px; right: 0; bottom: 0; overflow: hidden;
  }
  #canvas-area::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background-image: radial-gradient(circle, rgba(80,90,100,0.55) 1px, transparent 1px);
    background-size: 24px 24px; pointer-events: none;
  }
  #svg-layer {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
  }
  .edge-path { fill: none; stroke-width: 2; opacity: 0.6; transition: opacity 0.15s; pointer-events: visibleStroke; cursor: grab; }
  .edge-path:hover { opacity: 1; }
  .edge-hit { fill: none; stroke: transparent; stroke-width: 16; cursor: grab; pointer-events: stroke; }
  .edge-preview { fill: none; stroke: #c97bff; stroke-width: 2; stroke-dasharray: 6,4; opacity: 0.4; pointer-events: none; }

  /* Nodes */
  .node {
    position: absolute; background: #1c2128; border: 1px solid #30363d;
    border-radius: 6px; min-width: 170px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    user-select: none; transition: box-shadow 0.2s;
  }
  .node.selected { border-color: #c97bff; box-shadow: 0 0 0 1px #c97bff55, 0 4px 20px rgba(201,123,255,0.15); }
  .node.running  { box-shadow: 0 0 0 1px #58d68d33, 0 0 18px rgba(88,214,141,0.12); }
  .node-header {
    padding: 7px 10px; border-bottom: 1px solid #30363d; border-radius: 6px 6px 0 0;
    cursor: grab; display: flex; align-items: center; gap: 7px; background: #21262d;
  }
  .node-header:active { cursor: grabbing; }
  .node-color-dot { width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; }
  .node-title { font-size: 10px; font-weight: 600; color: #c9d1d9; flex: 1; letter-spacing: 0.5px; text-transform: uppercase; }
  .delete-btn { background: none; border: none; color: #484f58; cursor: pointer; font-size: 14px; line-height: 1; padding: 0 2px; transition: color 0.15s; }
  .delete-btn:hover { color: #f85149; }
  .node-body { padding: 10px 12px 6px; }
  .param-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; gap: 8px; }
  .param-label { font-size: 9px; color: #484f58; text-transform: uppercase; letter-spacing: 0.5px; flex-shrink: 0; }
  .param-input {
    background: #0f1117; border: 1px solid #30363d; border-radius: 3px;
    color: #c9d1d9; font-family: inherit; font-size: 11px; padding: 2px 6px;
    width: 90px; text-align: right; outline: none; transition: border-color 0.15s;
  }
  .param-input:focus { border-color: #c97bff; }
  .param-select {
    background: #0f1117; border: 1px solid #30363d; border-radius: 3px;
    color: #c9d1d9; font-family: inherit; font-size: 10px; padding: 2px 4px; width: 90px; outline: none;
  }

  /* VU bar */
  .vu-bar { height: 6px; border-radius: 3px; background: #21262d; overflow: hidden; margin-top: 4px; }
  .vu-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #58d68d, #d6a058, #f85149); transition: width 0.08s; border-radius: 3px; }

  /* Oscilloscope canvas */
  .scope-canvas {
    display: block; background: #000810;
    border-radius: 4px; border: 1px solid #1a3a1a;
    margin: 4px 0;
    box-shadow: inset 0 0 8px rgba(0,255,80,0.05);
    image-rendering: pixelated;
  }

  /* Ports */
  .node-ports { display: flex; justify-content: space-between; padding: 6px 0 6px; }
  .ports-in, .ports-out { display: flex; flex-direction: column; gap: 6px; }
  .ports-out { align-items: flex-end; }
  .port { display: flex; align-items: center; gap: 6px; cursor: crosshair; }
  .port.out { flex-direction: row-reverse; }
  .port-dot {
    width: 10px; height: 10px; border-radius: 50%; border: 2px solid #58d68d;
    background: #1c2128; transition: all 0.15s; position: relative; z-index: 10; flex-shrink: 0;
  }
  .port-dot::before {
    content: ''; position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%); width: 32px; height: 32px; border-radius: 50%;
  }
  .port-dot:hover, .port-dot.active { background: #58d68d; transform: scale(1.3); }
  .port-dot.in { border-color: #5da0d0; }
  .port-dot.in:hover { background: #5da0d0; }
  .port-dot.snap-target { background: #58d68d !important; transform: scale(1.8) !important; box-shadow: 0 0 0 4px rgba(88,214,141,0.3), 0 0 14px rgba(88,214,141,0.5); }
  .port-dot.in.snap-target { background: #5da0d0 !important; box-shadow: 0 0 0 4px rgba(93,160,208,0.3), 0 0 14px rgba(93,160,208,0.5); }
  .port-label { font-size: 9px; color: #484f58; text-transform: uppercase; letter-spacing: 0.5px; }

  #info-bar {
    position: fixed; bottom: 0; left: 180px; right: 0; height: 28px;
    background: #161b22; border-top: 1px solid #30363d;
    display: flex; align-items: center; padding: 0 16px; gap: 24px;
    font-size: 10px; color: #484f58; z-index: 50;
  }
  #info-bar span { color: #6e7681; }
  #status-msg { margin-left: auto; color: #58d68d; }

  /* ‚îÄ‚îÄ Perf monitor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  #perf-panel {
    position: absolute; bottom: 0; left: 0; right: 0;
    padding: 10px 8px 12px; border-top: 1px solid #30363d;
    background: #161b22;
  }
  .perf-label { font-size: 9px; letter-spacing: 2px; text-transform: uppercase; color: #484f58; margin-bottom: 6px; }
  .perf-row { display: flex; justify-content: space-between; font-size: 10px; color: #6e7681; margin-bottom: 4px; }
  .perf-val { color: #c9d1d9; font-variant-numeric: tabular-nums; }
  #perf-canvas { display: block; width: 100%; height: 40px; border-radius: 3px; background: #0f1117; border: 1px solid #21262d; margin-top: 6px; }

  /* ‚îÄ‚îÄ Sequencer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  .seq-grid {
    display: grid; gap: 3px; margin-top: 8px;
  }
  .seq-step {
    display: flex; flex-direction: column; align-items: center;
    background: #0f1117; border: 1px solid #30363d; border-radius: 3px;
    padding: 4px 2px; cursor: pointer; transition: background 0.1s, border-color 0.1s;
  }
  .seq-step.active   { background: #162216; border-color: #3a7a3a; }
  .seq-step.playing  { background: #1e3c1e; border-color: #58d68d;
                       box-shadow: 0 0 8px rgba(88,214,141,0.35); }
  .seq-step.inactive { opacity: 0.4; }
  .seq-step-num { font-size: 8px; color: #484f58; margin-bottom: 2px; }
  .seq-freq {
    background: none; border: none; color: #6a8a6a;
    font-family: inherit; font-size: 9px; width: 100%; text-align: center;
    outline: none; padding: 1px 0; cursor: text;
  }
  .seq-step.active  .seq-freq { color: #8ac98a; }
  .seq-step.playing .seq-freq { color: #58d68d; font-weight: 600; }
  .seq-bpm-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
  .seq-note-label {
    font-size: 8px; color: #58d68d; font-weight: 600;
    min-height: 10px; margin-top: 2px;
  }
@keyframes node-land {
  0%   { transform: scale(1, 1);    box-shadow: none; }
  12%  { transform: scale(1.015, 0.97); } /* brief compress on impact */
  35%  { transform: scale(0.99, 1.01); } /* tiny rebound */
  100% { transform: scale(1, 1); }
}
.node-land { animation: node-land 0.28s ease-out forwards; }
</style>
</head>
<body>

<div id="toolbar">
  <span class="logo">‚óà synth.html</span>
  <div class="tb-sep"></div>
  <button class="tb-btn play" id="play-btn" onclick="startAudio()">‚ñ∂ Play</button>
  <button class="tb-btn stop" id="stop-btn" onclick="stopAudio()">‚ñ† Stop</button>
  <div class="tb-sep"></div>
  <button class="tb-btn" onclick="clearAll()">Clear</button>
  <button class="tb-btn" onclick="autoArrange()">Auto Arrange</button>
  <select class="tb-select" id="preset-select" onchange="loadPreset(this.value); this.value=''">
    <option value="">Load preset‚Ä¶</option>
    <optgroup label="Built-in">
      <option value="drone">Drone</option>
      <option value="wobble">Wobble Bass</option>
      <option value="space">Space Echo</option>
      <option value="fuzz">Fuzz Lead</option>
      <option value="arpseq">Arp Sequencer</option>
      <option value="stereopan">Stereo Pan</option>
      <option value="pingpong">Ping-Pong Echo</option>
      <option value="keyjam">Keyboard Jam</option>
    </optgroup>
    <optgroup label="Saved" id="user-preset-group"></optgroup>
  </select>
  <button class="tb-btn" id="btn-save"   onclick="savePreset()"        style="border-color:#c97bff;color:#c97bff">Save</button>
  <button class="tb-btn" id="btn-delete" onclick="deleteCurrentPreset()" style="border-color:#f85149;color:#f85149;opacity:0.4" disabled>Delete</button>
  <button class="tb-btn" onclick="shareLink()" style="border-color:#58d68d;color:#58d68d" title="Copy shareable link">‚¨° Share</button>
  <div style="margin-left:auto; display:flex; align-items:center; gap:8px;">
    <span style="font-size:10px; color:#484f58;">VOL</span>
    <input id="master-vol" type="range" min="0" max="1" step="0.01" value="0.04"
      style="width:80px; accent-color:#58d68d; cursor:pointer"
      oninput="setMasterVol(this.value)">
    <span style="font-size:10px; color:#484f58; width:30px" id="vol-pct">10%</span>
    <div class="tb-sep"></div>
    <button class="tb-btn" onclick="toggleHelp()" title="Help" style="border-color:#c97bff;color:#c97bff;font-size:13px;padding:4px 10px">?</button>
  </div>
</div>

<!-- Help Modal -->
<div id="help-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.75);z-index:1000;display:none;align-items:center;justify-content:center">
  <div id="help-modal" style="background:#161b22;border:1px solid #30363d;border-radius:8px;max-width:560px;width:90%;max-height:80vh;overflow-y:auto;padding:32px;position:relative;font-size:12px;line-height:1.7">
    <button onclick="closeHelp()" style="position:absolute;top:14px;right:16px;background:none;border:none;color:#484f58;font-size:18px;cursor:pointer;line-height:1">‚úï</button>

    <div style="font-size:22px;font-weight:700;color:#c97bff;letter-spacing:1px;margin-bottom:4px">‚óà synth.html</div>
    <div style="color:#6e7681;font-size:11px;margin-bottom:20px;font-style:italic">a single HTML file that somehow makes music</div>

    <p style="color:#c9d1d9;margin-bottom:18px">
      A modular synthesizer that lives entirely in one <code style="background:#21262d;padding:1px 5px;border-radius:3px;color:#79c0ff">.html</code> file ‚Äî
      no server, no build step, no npm install, no existential dread.
      Drag nodes, patch cables, and sculpt sound like it's 1972 but your browser is the Moog.
    </p>

    <div style="color:#58d68d;font-size:10px;letter-spacing:2px;text-transform:uppercase;margin-bottom:10px">Getting Started</div>
    <div style="color:#c9d1d9;margin-bottom:18px">
      <div style="margin-bottom:6px">‚ë† Drag a node from the <strong style="color:#e0e0e0">left palette</strong> onto the canvas</div>
      <div style="margin-bottom:6px">‚ë° Connect nodes by dragging from an <strong style="color:#e0e0e0">output port</strong> (right side) to an <strong style="color:#e0e0e0">input port</strong> (left side)</div>
      <div style="margin-bottom:6px">‚ë¢ Grab a <strong style="color:#e0e0e0">wire mid-flight</strong> to rewire it</div>
      <div style="margin-bottom:6px">‚ë£ Hit <strong style="color:#58d68d">‚ñ∂ Play</strong> to start audio ‚Äî every patch needs a <strong style="color:#e0e0e0">Speaker</strong> node to make sound</div>
      <div>‚ë§ Not sure where to start? Load a <strong style="color:#e0e0e0">preset</strong> from the dropdown</div>
    </div>

    <div style="color:#58d68d;font-size:10px;letter-spacing:2px;text-transform:uppercase;margin-bottom:10px">Keyboard Shortcuts</div>
    <div style="display:grid;grid-template-columns:auto 1fr;gap:4px 16px;color:#c9d1d9;margin-bottom:18px">
      <span style="color:#c97bff;font-family:monospace">A S D F G H J K</span><span>white keys (C D E F G A B C)</span>
      <span style="color:#c97bff;font-family:monospace">W E T Y U</span><span>black keys (C# D# F# G# A#)</span>
      <span style="color:#c97bff;font-family:monospace">- / =</span><span>octave down / up</span>
      <span style="color:#c97bff;font-family:monospace">Delete</span><span>remove selected node</span>
    </div>

    <div style="color:#58d68d;font-size:10px;letter-spacing:2px;text-transform:uppercase;margin-bottom:10px">Tips</div>
    <div style="color:#c9d1d9;margin-bottom:8px">
      <div style="margin-bottom:5px">üîå <strong style="color:#e0e0e0">Port colors</strong> match node colors ‚Äî connect same-colored ports for cleaner patches</div>
      <div style="margin-bottom:5px">üéõÔ∏è <strong style="color:#e0e0e0">LFO ‚Üí freq_mod</strong> on any filter or oscillator gives you wobble and movement</div>
      <div style="margin-bottom:5px">üì° <strong style="color:#e0e0e0">‚¨° Share</strong> encodes your entire patch into the URL ‚Äî send it to someone</div>
      <div>üíæ <strong style="color:#e0e0e0">Save</strong> stores patches locally in your browser</div>
    </div>

    <div style="margin-top:20px;padding-top:16px;border-top:1px solid #21262d;color:#484f58;font-size:10px;text-align:center">
      made with ‚ô• and a single &lt;script&gt; tag ¬∑ open source ¬∑ no cookies ¬∑ no tracking ¬∑ just vibes
    </div>
  </div>
</div>

<div id="node-palette">
  <div class="palette-section">
    <div class="palette-label">Sources</div>
    <div class="palette-item pi-source" draggable="true" data-type="keyboard">
      <div class="item-name">Keyboard</div><div class="item-desc">Piano input</div>
    </div>
    <div class="palette-item pi-source" draggable="true" data-type="oscillator">
      <div class="item-name">Oscillator</div><div class="item-desc">Square/sine/saw/tri</div>
    </div>
    <div class="palette-item pi-source" draggable="true" data-type="noise">
      <div class="item-name">Noise</div><div class="item-desc">White noise</div>
    </div>
    <div class="palette-item pi-mod" draggable="true" data-type="sequencer">
      <div class="item-name">Sequencer</div><div class="item-desc">8-step note sequencer</div>
    </div>
  </div>
  <div class="palette-section">
    <div class="palette-label">Effects</div>
    <div class="palette-item pi-effect" draggable="true" data-type="gain">
      <div class="item-name">Gain</div><div class="item-desc">Volume / amplifier</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="filter">
      <div class="item-name">Filter</div><div class="item-desc">LP / HP / BP / notch</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="delay">
      <div class="item-name">Delay</div><div class="item-desc">Echo + feedback</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="ping_pong">
      <div class="item-name">Ping-Pong</div><div class="item-desc">Stereo bounce delay</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="reverb">
      <div class="item-name">Reverb</div><div class="item-desc">Convolution room</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="distortion">
      <div class="item-name">Distortion</div><div class="item-desc">Waveshaper drive</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="compressor">
      <div class="item-name">Compressor</div><div class="item-desc">Dynamics control</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="pan">
      <div class="item-name">Pan</div><div class="item-desc">Stereo position</div>
    </div>
    <div class="palette-item pi-effect" draggable="true" data-type="mixer">
      <div class="item-name">Mixer</div><div class="item-desc">3-channel sum + gain</div>
    </div>
  </div>
  <div class="palette-section">
    <div class="palette-label">Modulators</div>
    <div class="palette-item pi-mod" draggable="true" data-type="lfo">
      <div class="item-name">LFO</div><div class="item-desc">Modulate anything</div>
    </div>
  </div>
  <div class="palette-section">
    <div class="palette-label">Output</div>
    <div class="palette-item pi-sink" draggable="true" data-type="speaker">
      <div class="item-name">Speaker</div><div class="item-desc">Audio out + VU</div>
    </div>
  </div>
  <div class="palette-section">
    <div class="palette-label">Visualization</div>
    <div class="palette-item pi-sink" draggable="true" data-type="oscilloscope">
      <div class="item-name">Oscilloscope</div><div class="item-desc">Waveform display</div>
    </div>
    <div class="palette-item pi-sink" draggable="true" data-type="spectrum">
      <div class="item-name">Spectrum</div><div class="item-desc">FFT frequency bars</div>
    </div>
    <div class="palette-item pi-sink" draggable="true" data-type="xy_scope">
      <div class="item-name">XY Scope</div><div class="item-desc">Lissajous (X+Y)</div>
    </div>
    <div class="palette-item pi-sink" draggable="true" data-type="stereo_scope">
      <div class="item-name">Stereo Scope</div><div class="item-desc">L+R waveforms</div>
    </div>
  </div>
  <div id="perf-panel">
    <div class="perf-label">Performance</div>
    <div class="perf-row"><span>FPS</span><span class="perf-val" id="perf-fps">--</span></div>
    <div class="perf-row" id="perf-heap-row" style="display:none"><span>Heap</span><span class="perf-val" id="perf-heap">--</span></div>
    <canvas id="perf-canvas" width="164" height="40"></canvas>
  </div>
</div>

<div id="canvas-area"><svg id="svg-layer"></svg></div>

<div id="info-bar">
  <span>nodes: <span id="stat-nodes">0</span></span>
  <span>edges: <span id="stat-edges">0</span></span>
  <span id="status-msg"></span>
</div>

<script>
// ‚îÄ‚îÄ‚îÄ Node definitions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const NODE_DEFS = {
  oscillator: {
    label:'Oscillator', color:'#58d68d', kind:'source', ins:['freq','freq_mod'], outs:['signal'],
    params:{ freq:220, wave:'square' },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Freq</span>
        <input class="param-input" type="number" min="20" max="20000" value="${p.freq}"
          onchange="updateParam('${id}','freq',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Wave</span>
        <select class="param-select" onchange="updateParam('${id}','wave',this.value)">
          ${['square','sine','sawtooth','triangle'].map(w=>`<option value="${w}"${p.wave===w?' selected':''}>${w}</option>`).join('')}
        </select>
      </div>`; }
  },
  noise: {
    label:'Noise', color:'#58d68d', kind:'source', ins:[], outs:['signal'],
    params:{ level:0.5 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Level</span>
        <input class="param-input" type="number" min="0" max="1" step="0.05" value="${p.level}"
          onchange="updateParam('${id}','level',this.value)">
      </div>`; }
  },
  keyboard: {
    label:'Keyboard', color:'#c97bff', kind:'source', ins:[], outs:['freq'],
    minWidth: 220,
    params: { octave: 4 },
    renderBody(id, p) {
      return `
    <div class="param-row"><span class="param-label">Oct</span>
      <input class="param-input" type="number" min="1" max="7" value="${p.octave}"
        onchange="updateParam('${id}','octave',+this.value)">
    </div>
    <div class="kb-wrap" id="${id}-kb" style="position:relative;height:48px;margin-top:6px;user-select:none;">
      ${[0,2,4,5,7,9,11,12].map((semi,i) => `
        <div class="kb-white" data-id="${id}" data-semi="${semi}"
          style="position:absolute;left:${i*24}px;width:22px;height:48px;background:#e8e8e8;border:1px solid #333;border-radius:0 0 3px 3px;cursor:pointer;box-sizing:border-box"
          onmousedown="kbPress('${id}',${semi})" onmouseup="kbRelease('${id}',${semi})" onmouseleave="kbRelease('${id}',${semi})">
        </div>`).join('')}
      ${[[1,1],[3,2],[6,4],[8,5],[10,6]].map(([semi,wi]) => `
        <div class="kb-black" data-id="${id}" data-semi="${semi}"
          style="position:absolute;left:${wi*24-8}px;width:16px;height:30px;background:#222;border:1px solid #000;border-radius:0 0 2px 2px;z-index:1;cursor:pointer;box-sizing:border-box"
          onmousedown="kbPress('${id}',${semi})" onmouseup="kbRelease('${id}',${semi})" onmouseleave="kbRelease('${id}',${semi})">
        </div>`).join('')}
    </div>
    <div style="font-size:9px;color:#484f58;margin-top:4px">A-K = white keys ¬∑ W E T Y U = black</div>`;
    }
  },
  gain: {
    label:'Gain', color:'#5da0d0', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ gain:0.5 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Gain</span>
        <input class="param-input" type="number" min="0" max="2" step="0.05" value="${p.gain}"
          onchange="updateParam('${id}','gain',this.value)">
      </div>`; }
  },
  pan: {
    label:'Pan', color:'#5da0d0', kind:'effect', ins:['signal','pan_mod'], outs:['signal'],
    params:{ pan:0 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Pan</span>
        <input class="param-input" type="range" min="-1" max="1" step="0.01" value="${p.pan}"
          style="width:100px" oninput="updateParam('${id}','pan',+this.value);document.getElementById('${id}-panval').textContent=Math.round(+this.value*100)">
        <span id="${id}-panval" style="color:#6e7681;width:30px;text-align:right">${Math.round(p.pan*100)}</span>
      </div>`; }
  },
  filter: {
    label:'Filter', color:'#5da0d0', kind:'effect', ins:['signal','freq_mod'], outs:['signal'],
    params:{ type:'lowpass', freq:800, q:1 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Type</span>
        <select class="param-select" onchange="updateParam('${id}','type',this.value)">
          ${['lowpass','highpass','bandpass','notch'].map(t=>`<option value="${t}"${p.type===t?' selected':''}>${t}</option>`).join('')}
        </select>
      </div>
      <div class="param-row"><span class="param-label">Freq</span>
        <input class="param-input" type="number" min="20" max="20000" value="${p.freq}"
          onchange="updateParam('${id}','freq',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Q</span>
        <input class="param-input" type="number" min="0.1" max="30" step="0.1" value="${p.q}"
          onchange="updateParam('${id}','q',this.value)">
      </div>`; }
  },
  delay: {
    label:'Delay', color:'#5da0d0', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ time:0.3, feedback:0.4 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Time (s)</span>
        <input class="param-input" type="number" min="0" max="5" step="0.05" value="${p.time}"
          onchange="updateParam('${id}','time',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Feedback</span>
        <input class="param-input" type="number" min="0" max="0.95" step="0.05" value="${p.feedback}"
          onchange="updateParam('${id}','feedback',this.value)">
      </div>`; }
  },
  ping_pong: {
    label:'Ping-Pong', color:'#5da0d0', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ timeL:0.3, timeR:0.45, feedback:0.4, wet:0.5 },
    renderBody(id,p){ return `
    <div class="param-row"><span class="param-label">Time L</span>
      <input class="param-input" type="number" min="0.01" max="2" step="0.01" value="${p.timeL}"
        onchange="updateParam('${id}','timeL',+this.value)"></div>
    <div class="param-row"><span class="param-label">Time R</span>
      <input class="param-input" type="number" min="0.01" max="2" step="0.01" value="${p.timeR}"
        onchange="updateParam('${id}','timeR',+this.value)"></div>
    <div class="param-row"><span class="param-label">Feedback</span>
      <input class="param-input" type="number" min="0" max="0.95" step="0.01" value="${p.feedback}"
        onchange="updateParam('${id}','feedback',+this.value)"></div>
    <div class="param-row"><span class="param-label">Wet</span>
      <input class="param-input" type="number" min="0" max="1" step="0.05" value="${p.wet}"
        onchange="updateParam('${id}','wet',+this.value)"></div>`; }
  },
  reverb: {
    label:'Reverb', color:'#5da0d0', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ duration:2, decay:2, wet:0.5 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Duration</span>
        <input class="param-input" type="number" min="0.1" max="10" step="0.1" value="${p.duration}"
          onchange="updateParam('${id}','duration',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Decay</span>
        <input class="param-input" type="number" min="0.1" max="10" step="0.1" value="${p.decay}"
          onchange="updateParam('${id}','decay',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Wet</span>
        <input class="param-input" type="number" min="0" max="1" step="0.05" value="${p.wet}"
          onchange="updateParam('${id}','wet',this.value)">
      </div>`; }
  },
  distortion: {
    label:'Distortion', color:'#5da0d0', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ amount:50 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Amount</span>
        <input class="param-input" type="number" min="0" max="400" step="10" value="${p.amount}"
          onchange="updateParam('${id}','amount',this.value)">
      </div>`; }
  },
  compressor: {
    label:'Compressor', color:'#5da0d0', kind:'effect', ins:['signal'], outs:['signal'],
    params:{ threshold:-24, ratio:4, knee:10 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Threshold</span>
        <input class="param-input" type="number" min="-100" max="0" value="${p.threshold}"
          onchange="updateParam('${id}','threshold',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Ratio</span>
        <input class="param-input" type="number" min="1" max="20" step="0.5" value="${p.ratio}"
          onchange="updateParam('${id}','ratio',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Knee</span>
        <input class="param-input" type="number" min="0" max="40" value="${p.knee}"
          onchange="updateParam('${id}','knee',this.value)">
      </div>`; }
  },
  lfo: {
    label:'LFO', color:'#d6a058', kind:'mod', ins:[], outs:['mod'],
    params:{ freq:2, depth:100 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Rate (Hz)</span>
        <input class="param-input" type="number" min="0.01" max="30" step="0.1" value="${p.freq}"
          onchange="updateParam('${id}','freq',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Depth</span>
        <input class="param-input" type="number" min="0" max="5000" step="10" value="${p.depth}"
          onchange="updateParam('${id}','depth',this.value)">
      </div>`; }
  },
  speaker: {
    label:'Speaker', color:'#c97bff', kind:'sink', ins:['signal'], outs:[],
    params:{},
    renderBody(id,p){ return `<div class="vu-bar"><div class="vu-fill" id="${id}-vu"></div></div>`; }
  },
  oscilloscope: {
    label:'Oscilloscope', color:'#00dd66', kind:'sink', ins:['signal'], outs:[],
    params:{ zoom:1, mode:'standard' },
    renderBody(id,p){ return `
      <canvas class="scope-canvas" id="${id}-scope" width="158" height="80"></canvas>
      <div class="param-row" style="margin-top:4px"><span class="param-label">Zoom</span>
        <input class="param-input" type="number" min="0.1" max="10" step="0.1" value="${p.zoom}"
          onchange="updateParam('${id}','zoom',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Mode</span>
        <select class="param-select" onchange="updateParam('${id}','mode',this.value)">
          ${['standard','trippy','phosphor'].map(m=>`<option value="${m}"${(p.mode||'standard')===m?' selected':''}>${m}</option>`).join('')}
        </select>
      </div>`; }
  },

  spectrum: {
    label:'Spectrum', color:'#00dd66', kind:'sink', ins:['signal'], outs:[],
    params:{ mode:'standard' },
    renderBody(id,p){ return `
      <canvas class="scope-canvas" id="${id}-scope" width="158" height="80"></canvas>
      <div class="param-row" style="margin-top:4px"><span class="param-label">Mode</span>
        <select class="param-select" onchange="updateParam('${id}','mode',this.value)">
          ${['standard','trippy','phosphor'].map(m=>`<option value="${m}"${(p.mode||'standard')===m?' selected':''}>${m}</option>`).join('')}
        </select>
      </div>`; }
  },

  xy_scope: {
    label:'XY Scope', color:'#00dd66', kind:'sink', ins:['x','y'], outs:[],
    params:{ mode:'standard' },
    renderBody(id,p){ return `
      <canvas class="scope-canvas" id="${id}-scope" width="158" height="80"></canvas>
      <div class="param-row" style="margin-top:4px"><span class="param-label">Mode</span>
        <select class="param-select" onchange="updateParam('${id}','mode',this.value)">
          ${['standard','trippy','phosphor'].map(m=>`<option value="${m}"${(p.mode||'standard')===m?' selected':''}>${m}</option>`).join('')}
        </select>
      </div>`; }
  },

  stereo_scope: {
    label:'Stereo Scope', color:'#00dd66', kind:'sink', ins:['L','R'], outs:[],
    params:{ mode:'standard' },
    renderBody(id,p){ return `
      <canvas class="scope-canvas" id="${id}-scope" width="158" height="80"></canvas>
      <div class="param-row" style="margin-top:4px"><span class="param-label">Mode</span>
        <select class="param-select" onchange="updateParam('${id}','mode',this.value)">
          ${['standard','trippy','phosphor'].map(m=>`<option value="${m}"${(p.mode||'standard')===m?' selected':''}>${m}</option>`).join('')}
        </select>
      </div>`; }
  },

  mixer: {
    label:'Mixer', color:'#9b7bda', kind:'effect',
    ins:['ch1','ch2','ch3'], outs:['signal'],
    params:{ gain1:0.8, gain2:0.8, gain3:0.8 },
    renderBody(id,p){ return `
      <div class="param-row"><span class="param-label">Ch 1</span>
        <input class="param-input" type="number" min="0" max="2" step="0.05" value="${p.gain1}"
          onchange="updateParam('${id}','gain1',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Ch 2</span>
        <input class="param-input" type="number" min="0" max="2" step="0.05" value="${p.gain2}"
          onchange="updateParam('${id}','gain2',this.value)">
      </div>
      <div class="param-row"><span class="param-label">Ch 3</span>
        <input class="param-input" type="number" min="0" max="2" step="0.05" value="${p.gain3}"
          onchange="updateParam('${id}','gain3',this.value)">
      </div>`; }
  },

  sequencer: {
    label:'Sequencer', color:'#d6a058', kind:'mod',
    minWidth: 290,
    ins:[], outs:['freq'],
    params:{
      bpm: 120,
      notes: [220, 294, 330, 392, 440, 392, 330, 294],
      active:[1,   1,   1,   1,   1,   0,   1,   0  ]
    },
    renderBody(id,p){
      const notes  = p.notes;
      const active = p.active;
      let steps = `
      <div class="seq-bpm-row">
        <span class="param-label">BPM</span>
        <input class="param-input" type="number" min="30" max="300" value="${p.bpm}" style="width:70px"
          onchange="updateParam('${id}','bpm',+this.value)">
      </div>
      <div class="seq-grid" id="${id}-grid" style="grid-template-columns:repeat(8,1fr)">`;
      for (let i = 0; i < 8; i++) {
        const cls = active[i] ? 'active' : 'inactive';
        steps += `
        <div class="seq-step ${cls}" id="${id}-s${i}" onclick="toggleStep('${id}',${i})">
          <span class="seq-step-num">${i+1}</span>
          <input class="seq-freq" type="number" value="${notes[i]}"
            onclick="event.stopPropagation()"
            onchange="updateStepFreq('${id}',${i},+this.value)">
        </div>`;
      }
      steps += `</div>`;
      return steps;
    }
  },
};

// ‚îÄ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let nodes={}, edges=[], nodeIdCounter=0;
let dragging=null, dragOffset={x:0,y:0};
let connecting=null, previewPath=null, selectedNode=null;
let edgeEls=[]; // [{pathEl, hitEl, edge}] ‚Äî for wire animation
let wireRafId=null;
const edgeSprings={}; // edgeKey‚Üí{y,vy} spring offset per wire
function edgeSpringKey(e){return`${e.srcNode}:${e.srcPort}‚Üí${e.dstNode}:${e.dstPort}`;}
function getEdgeSpring(edge){
  const k=edgeSpringKey(edge);
  if(!edgeSprings[k]) edgeSprings[k]={y:0,vy:0};
  return edgeSprings[k];
}
let audioCtx=null, audioNodes={}, masterGain=null;
let rafId=null;
let seqState={};
let canvasScale=1.0; // { [nodeId]: { step, intervalId } }
const GRID=24;
function snap(v){return Math.round(v/GRID)*GRID;}
let scopeHistory={}; // { [nodeId]: Uint8Array[] } ‚Äî ring buffer for trippy echo
let activeKbNode = null; // id of focused keyboard node

const canvasEl = document.getElementById('canvas-area');
const svgLayer = document.getElementById('svg-layer');

// ‚îÄ‚îÄ‚îÄ Create node ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function createNode(type, x, y, overrideParams={}) {
  const def = NODE_DEFS[type];
  if (!def) return;
  x=snap(x); y=snap(y);
  const id = 'n'+(++nodeIdCounter);
  // Deep-copy params so array values (e.g. sequencer notes/active) aren't shared
  const params = {};
  for (const [k,v] of Object.entries(def.params)) params[k] = Array.isArray(v) ? [...v] : v;
  Object.assign(params, overrideParams);
  nodes[id] = { id, type, def, x, y, params };

  const el = document.createElement('div');
  el.className = 'node'; el.id = id;
  el.style.left = x+'px'; el.style.top = y+'px';
  if (def.minWidth) el.style.minWidth = def.minWidth+'px';

  const inPorts  = def.ins.map(p=>`
    <div class="port in" data-node="${id}" data-port="${p}" data-dir="in">
      <div class="port-dot in" data-node="${id}" data-port="${p}" data-dir="in"></div>
      <span class="port-label">${p}</span>
    </div>`).join('');
  const outPorts = def.outs.map(p=>`
    <div class="port out" data-node="${id}" data-port="${p}" data-dir="out">
      <span class="port-label">${p}</span>
      <div class="port-dot out" data-node="${id}" data-port="${p}" data-dir="out"></div>
    </div>`).join('');

  el.innerHTML = `
    <div class="node-header" data-node="${id}">
      <div class="node-color-dot" style="background:${def.color}"></div>
      <span class="node-title">${def.label}</span>
      <button class="delete-btn" onclick="deleteNode('${id}')">√ó</button>
    </div>
    <div class="node-body">${def.renderBody(id,params)}</div>
    <div class="node-ports">
      <div class="ports-in">${inPorts}</div>
      <div class="ports-out">${outPorts}</div>
    </div>`;

  canvasEl.appendChild(el);
  el.querySelector('.node-header').addEventListener('mousedown', onHeaderMousedown);
  el.querySelectorAll('.port-dot').forEach(d => d.addEventListener('mousedown', onPortMousedown));
  updateStats();
  return id;
}

function updateParam(id, key, val) {
  if (!nodes[id]) return;
  nodes[id].params[key] = val;
  if (!audioCtx || !audioNodes[id]) return;
  const an = audioNodes[id];
  const t = audioCtx.currentTime;
  try {
    const n = nodes[id];
    if (n.type==='oscillator') {
      if (key==='freq') an.main.frequency.setTargetAtTime(+val,t,0.01);
      if (key==='wave') an.main.type = val;
    } else if (n.type==='noise') {
      if (key==='level') an.gainNode.gain.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='pan') {
      if (key==='pan') an.main.pan.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='gain') {
      if (key==='gain') an.main.gain.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='filter') {
      if (key==='type') an.main.type=val;
      if (key==='freq') an.main.frequency.setTargetAtTime(+val,t,0.01);
      if (key==='q') an.main.Q.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='delay') {
      if (key==='time') an.main.delayTime.setTargetAtTime(+val,t,0.01);
      if (key==='feedback') an.feedback.gain.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='ping_pong') {
      if (key==='timeL') an.delayL.delayTime.setTargetAtTime(+val,t,0.01);
      if (key==='timeR') an.delayR.delayTime.setTargetAtTime(+val,t,0.01);
      if (key==='feedback') { an.fbL.gain.setTargetAtTime(+val,t,0.01); an.fbR.gain.setTargetAtTime(+val,t,0.01); }
      if (key==='wet') { an.wet.gain.setTargetAtTime(+val,t,0.01); an.dry.gain.setTargetAtTime(1-+val,t,0.01); }
    } else if (n.type==='compressor') {
      if (key==='threshold') an.main.threshold.setTargetAtTime(+val,t,0.01);
      if (key==='ratio') an.main.ratio.setTargetAtTime(+val,t,0.01);
      if (key==='knee') an.main.knee.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='lfo') {
      if (key==='freq') an.osc.frequency.setTargetAtTime(+val,t,0.01);
      if (key==='depth') an.depth.gain.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='mixer') {
      if (key==='gain1') an.ch1.gain.setTargetAtTime(+val,t,0.01);
      if (key==='gain2') an.ch2.gain.setTargetAtTime(+val,t,0.01);
      if (key==='gain3') an.ch3.gain.setTargetAtTime(+val,t,0.01);
    } else if (n.type==='sequencer') {
      if (key==='bpm' && seqState[id]) {
        clearInterval(seqState[id].intervalId);
        const tick=()=>{
          if(!audioCtx||!nodes[id]) return;
          const p=nodes[id].params, step=seqState[id].step;
          for(let i=0;i<8;i++) document.getElementById(`${id}-s${i}`)?.classList.remove('playing');
          if(p.active[step]){
            const freq=p.notes[step];
            edges.filter(e=>e.srcNode===id).forEach(e=>{
              const an=audioNodes[e.dstNode];
              if(an?.main?.frequency) an.main.frequency.setValueAtTime(freq, audioCtx.currentTime);
            });
          }
          document.getElementById(`${id}-s${seqState[id].step}`)?.classList.add('playing');
          seqState[id].step=(step+1)%8;
        };
        seqState[id].intervalId=setInterval(tick, 60000/+val);
      }
    }
  } catch(e) {}
}

// ‚îÄ‚îÄ‚îÄ Keyboard node helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function noteFreq(semi, octave) {
  const midiNote = (octave + 1) * 12 + semi;
  return 440 * Math.pow(2, (midiNote - 69) / 12);
}

function kbPress(nodeId, semi) {
  if (!audioCtx) return;
  const octave = +nodes[nodeId]?.params?.octave || 4;
  const freq = noteFreq(semi, octave);
  document.querySelectorAll(`#${nodeId}-kb [data-semi="${semi}"]`).forEach(el => {
    el.style.background = el.classList.contains('kb-black') ? '#5da0d0' : '#b3d4ff';
  });
  edges.filter(e => e.srcNode === nodeId).forEach(e => {
    const an = audioNodes[e.dstNode];
    if (an?.main?.frequency) an.main.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.005);
    if (nodes[e.dstNode]?.params?.freq !== undefined) nodes[e.dstNode].params.freq = freq;
  });
  activeKbNode = nodeId;
}

function kbRelease(nodeId, semi) {
  document.querySelectorAll(`#${nodeId}-kb [data-semi="${semi}"]`).forEach(el => {
    el.style.background = el.classList.contains('kb-black') ? '#222' : '#e8e8e8';
  });
}

// ‚îÄ‚îÄ‚îÄ Sequencer helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function toggleStep(id, i) {
  if (!nodes[id]) return;
  const p = nodes[id].params;
  p.active[i] = p.active[i] ? 0 : 1;
  const el = document.getElementById(`${id}-s${i}`);
  if (el) {
    el.classList.toggle('active',   !!p.active[i]);
    el.classList.toggle('inactive', !p.active[i]);
  }
}
function updateStepFreq(id, i, val) {
  if (!nodes[id]) return;
  nodes[id].params.notes[i] = val;
}

// ‚îÄ‚îÄ‚îÄ Drag nodes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function onHeaderMousedown(e) {
  if (e.target.classList.contains('delete-btn')) return;
  e.preventDefault();
  const id = e.currentTarget.dataset.node;
  dragging = id;
  const el = document.getElementById(id);
  const r = el.getBoundingClientRect();
  dragOffset.x = e.clientX - r.left;
  dragOffset.y = e.clientY - r.top;
  selectNode(id);
}

document.addEventListener('mousemove', e => {
  if (dragging) {
    const cr = canvasEl.getBoundingClientRect();
    const x = Math.max(0, (e.clientX - cr.left - dragOffset.x) / canvasScale);
    const y = Math.max(0, (e.clientY - cr.top  - dragOffset.y) / canvasScale);
    const el = document.getElementById(dragging);
    el.style.left = x+'px'; el.style.top = y+'px';
    nodes[dragging].x = x; nodes[dragging].y = y;
    renderEdges();
  }
  if (connecting) {
    const cr = canvasEl.getBoundingClientRect();
    const mx = (e.clientX-cr.left)/canvasScale, my = (e.clientY-cr.top)/canvasScale;
    if (!previewPath) {
      previewPath = document.createElementNS('http://www.w3.org/2000/svg','path');
      previewPath.classList.add('edge-preview');
      svgLayer.appendChild(previewPath);
    }
    const src = getPortPos(connecting.nodeId, connecting.port, connecting.dir);
    const targetDir = connecting.dir==='out'?'in':'out';
    let snapDot=null, snapDist=Infinity;
    document.querySelectorAll(`.port-dot.${targetDir}`).forEach(dot=>{
      if (dot.dataset.node===connecting.nodeId) return;
      const r=dot.getBoundingClientRect();
      const dist=Math.hypot(mx-(r.left+r.width/2-cr.left)/canvasScale, my-(r.top+r.height/2-cr.top)/canvasScale);
      if (dist<40 && dist<snapDist){snapDist=dist;snapDot=dot;}
    });
    document.querySelectorAll('.port-dot.snap-target').forEach(d=>d.classList.remove('snap-target'));
    if (snapDot) {
      snapDot.classList.add('snap-target');
      const r=snapDot.getBoundingClientRect();
      previewPath.setAttribute('d',bezier(src.x,src.y,(r.left+r.width/2-cr.left)/canvasScale,(r.top+r.height/2-cr.top)/canvasScale));
    } else {
      previewPath.setAttribute('d',bezier(src.x,src.y,mx,my));
    }
  }
});

document.addEventListener('mouseup', e=>{
  if (dragging) {
    // Drop bounce: connected wires spring, then ripple to one-hop neighbors
    const dropped=dragging;
    dragging=null;
    // Snap to grid on release
    const sx=snap(nodes[dropped].x), sy=snap(nodes[dropped].y);
    nodes[dropped].x=sx; nodes[dropped].y=sy;
    const snapEl=document.getElementById(dropped);
    if(snapEl){snapEl.style.left=sx+'px'; snapEl.style.top=sy+'px';}
    renderEdges();
    // Node land animation
    const landEl=document.getElementById(dropped);
    if(landEl){
      landEl.classList.remove('node-land');
      void landEl.offsetWidth; // force reflow to restart animation
      landEl.classList.add('node-land');
      landEl.addEventListener('animationend',()=>landEl.classList.remove('node-land'),{once:true});
    }
    const neighborNodes=new Set();
    edges.forEach(edge=>{
      if(edge.srcNode===dropped||edge.dstNode===dropped){
        const sp=getEdgeSpring(edge);
        sp.y=-32; sp.vy=0; // primary bounce
        // collect the other end of each wire
        neighborNodes.add(edge.srcNode===dropped?edge.dstNode:edge.srcNode);
      }
    });
    // Ripple: wires connected to neighbor nodes (but not the dropped node) get a gentler bounce
    edges.forEach(edge=>{
      if(edge.srcNode===dropped||edge.dstNode===dropped) return; // already handled
      const touchesNeighbor=neighborNodes.has(edge.srcNode)||neighborNodes.has(edge.dstNode);
      if(touchesNeighbor){
        const sp=getEdgeSpring(edge);
        sp.y=-5; sp.vy=0;
      }
    });
  }
  if (connecting) {
    document.querySelectorAll('.port-dot.snap-target').forEach(d=>d.classList.remove('snap-target'));
    const cr=canvasEl.getBoundingClientRect();
    const mx=(e.clientX-cr.left)/canvasScale, my=(e.clientY-cr.top)/canvasScale;
    const targetDir=connecting.dir==='out'?'in':'out';
    let resolved=null;
    if (e.target?.classList?.contains('port-dot') && e.target.dataset.dir===targetDir && e.target.dataset.node!==connecting.nodeId)
      resolved=e.target;
    if (!resolved) {
      let bestDist=Infinity;
      document.querySelectorAll(`.port-dot.${targetDir}`).forEach(dot=>{
        if (dot.dataset.node===connecting.nodeId) return;
        const r=dot.getBoundingClientRect();
        const dist=Math.hypot(mx-(r.left+r.width/2-cr.left)/canvasScale,my-(r.top+r.height/2-cr.top)/canvasScale);
        if (dist<40 && dist<bestDist){bestDist=dist;resolved=dot;}
      });
    }
    if (resolved) {
      const [sN,sP,dN,dP]=connecting.dir==='out'
        ?[connecting.nodeId,connecting.port,resolved.dataset.node,resolved.dataset.port]
        :[resolved.dataset.node,resolved.dataset.port,connecting.nodeId,connecting.port];
      addEdge(sN,sP,dN,dP);
    }
    if (previewPath){previewPath.remove();previewPath=null;}
    connecting=null;
  }
});

// ‚îÄ‚îÄ‚îÄ Ports ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function onPortMousedown(e) {
  e.preventDefault(); e.stopPropagation();
  connecting={nodeId:e.currentTarget.dataset.node,port:e.currentTarget.dataset.port,dir:e.currentTarget.dataset.dir};
}
function addEdge(sN,sP,dN,dP) {
  if (edges.find(e=>e.srcNode===sN&&e.srcPort===sP&&e.dstNode===dN&&e.dstPort===dP)) return;
  const edge={id:'e'+edges.length,srcNode:sN,srcPort:sP,dstNode:dN,dstPort:dP};
  edges.push(edge);
  // Spring: start pulled upward, bounces into place
  edgeSprings[edgeSpringKey(edge)]={y:-45,vy:0};
  renderEdges(); updateStats();
}
function deleteEdge(idx){edges.splice(idx,1);renderEdges();updateStats();}
function deleteNode(id){
  edges=edges.filter(e=>e.srcNode!==id&&e.dstNode!==id);
  document.getElementById(id)?.remove(); delete nodes[id];
  renderEdges(); updateStats();
}
function selectNode(id){
  if(selectedNode) document.getElementById(selectedNode)?.classList.remove('selected');
  selectedNode=id; document.getElementById(id)?.classList.add('selected');
}
function getPortPos(nodeId,portName,dir){
  const el=document.getElementById(nodeId);
  if(!el) return null;
  const cr=canvasEl.getBoundingClientRect();
  for (const p of el.querySelectorAll('.port-dot'))
    if (p.dataset.port===portName&&p.dataset.dir===dir){
      const r=p.getBoundingClientRect();
      return{x:(r.left+r.width/2-cr.left)/canvasScale,y:(r.top+r.height/2-cr.top)/canvasScale};
    }
  const r=el.getBoundingClientRect();
  return{x:(r.left-cr.left)/canvasScale,y:(r.top+r.height/2-cr.top)/canvasScale};
}
function bezier(x1,y1,x2,y2,extraSag=0){
  const dx=Math.max(Math.abs(x2-x1)*0.5,40);
  const dist=Math.hypot(x2-x1,y2-y1);
  const sag=Math.min(dist*0.18,70)+extraSag; // gravity droop ‚Äî longer = more sag
  return`M${x1} ${y1} C${x1+dx} ${y1+sag*0.55},${x2-dx} ${y2+sag*0.55},${x2} ${y2}`;
}
function renderEdges(){
  svgLayer.querySelectorAll('.edge-path,.edge-hit').forEach(p=>p.remove());
  edgeEls=[];
  edges.forEach((edge,idx)=>{
    if(!nodes[edge.srcNode]||!nodes[edge.dstNode]) return;
    const src=getPortPos(edge.srcNode,edge.srcPort,'out');
    const dst=getPortPos(edge.dstNode,edge.dstPort,'in');
    const d=bezier(src.x,src.y,dst.x,dst.y);
    const color=nodes[edge.srcNode].def.color;

    function grabEdge(e){
      e.preventDefault(); e.stopPropagation();
      const cr=canvasEl.getBoundingClientRect();
      const mx=(e.clientX-cr.left)/canvasScale, my=(e.clientY-cr.top)/canvasScale;
      const dSrc=Math.hypot(mx-src.x,my-src.y);
      const dDst=Math.hypot(mx-dst.x,my-dst.y);
      const fixedNode = dDst<=dSrc ? edge.srcNode : edge.dstNode;
      const fixedPort = dDst<=dSrc ? edge.srcPort : edge.dstPort;
      const fixedDir  = dDst<=dSrc ? 'out'        : 'in';
      deleteEdge(idx);
      connecting={nodeId:fixedNode, port:fixedPort, dir:fixedDir};
    }

    const hit=document.createElementNS('http://www.w3.org/2000/svg','path');
    hit.classList.add('edge-hit'); hit.setAttribute('d',d);
    hit.addEventListener('mousedown', grabEdge);
    svgLayer.insertBefore(hit,previewPath);

    const path=document.createElementNS('http://www.w3.org/2000/svg','path');
    path.classList.add('edge-path'); path.setAttribute('d',d); path.setAttribute('stroke',color);
    path.addEventListener('mousedown', grabEdge);
    svgLayer.insertBefore(path,previewPath);

    // Store refs for wire animation
    edgeEls.push({pathEl:path, hitEl:hit, edge});
  });
}

// ‚îÄ‚îÄ‚îÄ Wire physics animation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function animateWires(){
  wireRafId=requestAnimationFrame(animateWires);
  edgeEls.forEach(({pathEl,hitEl,edge})=>{
    if(!nodes[edge.srcNode]||!nodes[edge.dstNode]) return;
    const src=getPortPos(edge.srcNode,edge.srcPort,'out');
    const dst=getPortPos(edge.dstNode,edge.dstPort,'in');
    if(!src||!dst) return;
    // Spring physics: settle toward y=0 (natural sag position)
    const sp=getEdgeSpring(edge);
    sp.vy += -0.12 * sp.y; // spring force
    sp.vy *= 0.86;          // damping ‚Äî looser = more oscillations
    sp.y  += sp.vy;
    if(Math.abs(sp.y)<0.1&&Math.abs(sp.vy)<0.05) sp.y=sp.vy=0; // settle
    const d=bezier(src.x,src.y,dst.x,dst.y,sp.y);
    pathEl.setAttribute('d',d);
    hitEl.setAttribute('d',d);
  });
}
animateWires(); // DOM is ready since script is at end of body

// ‚îÄ‚îÄ‚îÄ Palette drag/drop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.querySelectorAll('.palette-item').forEach(item=>
  item.addEventListener('dragstart',e=>e.dataTransfer.setData('type',item.dataset.type)));
canvasEl.addEventListener('dragover',e=>e.preventDefault());
canvasEl.addEventListener('drop',e=>{
  e.preventDefault();
  const type=e.dataTransfer.getData('type'); if(!type) return;
  const cr=canvasEl.getBoundingClientRect();
  const id=createNode(type,snap((e.clientX-cr.left)/canvasScale-85),snap((e.clientY-cr.top)/canvasScale-30));
  // Land animation on palette drop
  requestAnimationFrame(()=>{
    const el=document.getElementById(id);
    if(el){ el.classList.add('node-land'); el.addEventListener('animationend',()=>el.classList.remove('node-land'),{once:true}); }
  });
});

// ‚îÄ‚îÄ‚îÄ Audio helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function makeDistortionCurve(amount){
  const n=256,curve=new Float32Array(n);
  for(let i=0;i<n;i++){const x=(i*2)/n-1;curve[i]=((Math.PI+amount)*x)/(Math.PI+amount*Math.abs(x));}
  return curve;
}
function makeReverbIR(ctx,duration,decay){
  const len=ctx.sampleRate*duration;
  const buf=ctx.createBuffer(2,len,ctx.sampleRate);
  for(let c=0;c<2;c++){
    const d=buf.getChannelData(c);
    for(let i=0;i<len;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/len,decay);
  }
  return buf;
}

// ‚îÄ‚îÄ‚îÄ Audio engine ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function setMasterVol(v) {
  document.getElementById('vol-pct').textContent = Math.round(v*100)+'%';
  if (masterGain) masterGain.gain.setTargetAtTime(+v, audioCtx.currentTime, 0.01);
}

function startAudio(){
  if(audioCtx) return;
  audioCtx=new(window.AudioContext||window.webkitAudioContext)();
  audioNodes={};
  masterGain=audioCtx.createGain();
  masterGain.gain.value=+document.getElementById('master-vol').value;
  // Limiter to prevent clipping when signals sum loud
  const limiter=audioCtx.createDynamicsCompressor();
  limiter.threshold.value=-18; limiter.knee.value=6;
  limiter.ratio.value=20; limiter.attack.value=0.001; limiter.release.value=0.15;
  masterGain.connect(limiter);
  limiter.connect(audioCtx.destination);

  Object.values(nodes).forEach(n=>{
    const p=n.params;
    switch(n.type){
      case'oscillator':{
        const osc=audioCtx.createOscillator();
        osc.type=p.wave; osc.frequency.value=+p.freq;
        audioNodes[n.id]={main:osc,input:null,output:osc,
          audioParams:{freq_mod:osc.frequency}};
        break;
      }
      case'noise':{
        const sz=audioCtx.sampleRate*2;
        const buf=audioCtx.createBuffer(1,sz,audioCtx.sampleRate);
        const d=buf.getChannelData(0);
        for(let i=0;i<sz;i++) d[i]=Math.random()*2-1;
        const src=audioCtx.createBufferSource();
        src.buffer=buf; src.loop=true;
        const g=audioCtx.createGain(); g.gain.value=+p.level;
        src.connect(g);
        audioNodes[n.id]={main:src,gainNode:g,input:null,output:g};
        break;
      }
      case'gain':{
        const g=audioCtx.createGain(); g.gain.value=+p.gain;
        audioNodes[n.id]={main:g,input:g,output:g};
        break;
      }
      case'pan':{
        const panner=audioCtx.createStereoPanner(); panner.pan.value=+p.pan;
        audioNodes[n.id]={main:panner,input:panner,output:panner,audioParams:{pan_mod:panner.pan}};
        break;
      }
      case'filter':{
        const f=audioCtx.createBiquadFilter();
        f.type=p.type; f.frequency.value=+p.freq; f.Q.value=+p.q;
        audioNodes[n.id]={main:f,input:f,output:f,
          audioParams:{freq_mod:f.frequency}};
        break;
      }
      case'delay':{
        const d=audioCtx.createDelay(10); d.delayTime.value=+p.time;
        const fb=audioCtx.createGain(); fb.gain.value=+p.feedback;
        d.connect(fb); fb.connect(d);
        audioNodes[n.id]={main:d,feedback:fb,input:d,output:d};
        break;
      }
      case'ping_pong':{
        const delayL=audioCtx.createDelay(2.0); delayL.delayTime.value=+p.timeL;
        const delayR=audioCtx.createDelay(2.0); delayR.delayTime.value=+p.timeR;
        const fbL=audioCtx.createGain(); fbL.gain.value=+p.feedback;
        const fbR=audioCtx.createGain(); fbR.gain.value=+p.feedback;
        const merge=audioCtx.createChannelMerger(2);
        const dry=audioCtx.createGain(); dry.gain.value=1-+p.wet;
        const wet=audioCtx.createGain(); wet.gain.value=+p.wet;
        const input=audioCtx.createGain();
        const output=audioCtx.createGain();
        input.connect(delayL);
        delayL.connect(fbL); fbL.connect(delayR);
        delayR.connect(fbR); fbR.connect(delayL);
        delayL.connect(merge,0,0);
        delayR.connect(merge,0,1);
        merge.connect(wet); wet.connect(output);
        input.connect(dry); dry.connect(output);
        audioNodes[n.id]={main:output,input,output,delayL,delayR,fbL,fbR,dry,wet};
        break;
      }
      case'reverb':{
        const conv=audioCtx.createConvolver();
        conv.buffer=makeReverbIR(audioCtx,+p.duration,+p.decay);
        const dry=audioCtx.createGain(); dry.gain.value=1-+p.wet;
        const wet=audioCtx.createGain(); wet.gain.value=+p.wet;
        const inn=audioCtx.createGain();  // input splitter
        const out=audioCtx.createGain();  // output merger
        inn.connect(dry); inn.connect(conv); conv.connect(wet);
        dry.connect(out); wet.connect(out);
        audioNodes[n.id]={main:conv,input:inn,output:out,dry,wet:wet};
        break;
      }
      case'distortion':{
        const ws=audioCtx.createWaveShaper();
        ws.curve=makeDistortionCurve(+p.amount); ws.oversample='4x';
        audioNodes[n.id]={main:ws,input:ws,output:ws};
        break;
      }
      case'compressor':{
        const c=audioCtx.createDynamicsCompressor();
        c.threshold.value=+p.threshold; c.ratio.value=+p.ratio; c.knee.value=+p.knee;
        audioNodes[n.id]={main:c,input:c,output:c};
        break;
      }
      case'mixer':{
        const ch1=audioCtx.createGain(); ch1.gain.value=+p.gain1;
        const ch2=audioCtx.createGain(); ch2.gain.value=+p.gain2;
        const ch3=audioCtx.createGain(); ch3.gain.value=+p.gain3;
        const out=audioCtx.createGain(); out.gain.value=1;
        ch1.connect(out); ch2.connect(out); ch3.connect(out);
        audioNodes[n.id]={main:out, input:ch1, inputs:{ch1,ch2,ch3}, output:out, ch1,ch2,ch3};
        break;
      }
      case'lfo':{
        const osc=audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value=+p.freq;
        const depth=audioCtx.createGain(); depth.gain.value=+p.depth;
        osc.connect(depth);
        audioNodes[n.id]={osc,depth,main:osc,input:null,output:depth};
        break;
      }
      case'speaker':{
        const analyser=audioCtx.createAnalyser(); analyser.fftSize=256;
        analyser.connect(masterGain);
        audioNodes[n.id]={main:analyser,input:analyser,output:analyser,analyser};
        break;
      }
      case'oscilloscope':{
        const analyser=audioCtx.createAnalyser(); analyser.fftSize=512;
        audioNodes[n.id]={main:analyser,input:analyser,output:analyser,analyser};
        break;
      }
      case'spectrum':{
        const analyser=audioCtx.createAnalyser(); analyser.fftSize=2048;
        audioNodes[n.id]={main:analyser,input:analyser,output:analyser,analyser};
        break;
      }
      case'xy_scope':{
        const analyserX=audioCtx.createAnalyser(); analyserX.fftSize=512;
        const analyserY=audioCtx.createAnalyser(); analyserY.fftSize=512;
        audioNodes[n.id]={main:analyserX,input:analyserX,output:null,
          analyserX,analyserY, inputs:{x:analyserX,y:analyserY}};
        break;
      }
      case'stereo_scope':{
        const analyserL=audioCtx.createAnalyser(); analyserL.fftSize=512;
        const analyserR=audioCtx.createAnalyser(); analyserR.fftSize=512;
        audioNodes[n.id]={main:analyserL,input:analyserL,output:null,
          analyserL,analyserR, inputs:{L:analyserL,R:analyserR}};
        break;
      }
      case'sequencer':{
        // No real Web Audio node ‚Äî sequencer drives connected osc frequencies via JS timing
        audioNodes[n.id]={main:null,input:null,output:null};
        break;
      }
      case'keyboard':{
        // No audio node ‚Äî keyboard drives connected oscillator frequencies via JS events
        audioNodes[n.id]={main:null,input:null,output:null};
        break;
      }
    }
  });

  // Wire edges (skip sequencer ‚Äî it drives oscillators via JS timing)
  edges.forEach(edge=>{
    if(nodes[edge.srcNode]?.type==='sequencer') return; // handled separately
    if(nodes[edge.srcNode]?.type==='keyboard') return; // handled via kbPress JS events
    const src=audioNodes[edge.srcNode], dst=audioNodes[edge.dstNode];
    if(!src||!dst) return;
    // AudioParam modulation (e.g. freq_mod ‚Üí filter.frequency)
    const dstParam  = dst.audioParams?.[edge.dstPort];
    // per-port input routing (e.g. mixer channels)
    const dstInput  = dst.inputs?.[edge.dstPort] ?? dst.input;
    const target = dstParam ?? dstInput;
    if(!target) return;
    try{src.output.connect(target);}catch(e){console.warn('connect failed',e);}
  });

  // Start sources
  Object.values(audioNodes).forEach(an=>{
    try{if(an.osc)an.osc.start();else if(an.main?.start)an.main.start();}catch(e){}
  });

  // Start sequencers
  Object.values(nodes).filter(n=>n.type==='sequencer').forEach(n=>{
    seqState[n.id]={step:0};
    const tick=()=>{
      if(!audioCtx||!nodes[n.id]) return;
      const p=nodes[n.id].params;
      const step=seqState[n.id].step;
      // Clear previous playing highlights
      for(let i=0;i<8;i++) document.getElementById(`${n.id}-s${i}`)?.classList.remove('playing');
      if(p.active[step]){
        const freq=p.notes[step];
        edges.filter(e=>e.srcNode===n.id).forEach(e=>{
          const an=audioNodes[e.dstNode];
          if(an?.main?.frequency) an.main.frequency.setValueAtTime(freq, audioCtx.currentTime);
        });
      }
      document.getElementById(`${n.id}-s${step}`)?.classList.add('playing');
      seqState[n.id].step=(step+1)%8;
    };
    tick(); // fire first step immediately
    seqState[n.id].intervalId=setInterval(tick, 60000/+n.params.bpm);
  });

  // Animation loop ‚Äî VU + scope
  function drawLoop(){
    rafId=requestAnimationFrame(drawLoop);
    // VU meters
    Object.values(nodes).filter(n=>n.type==='speaker').forEach(n=>{
      const an=audioNodes[n.id]; const el=document.getElementById(n.id+'-vu');
      if(!an?.analyser||!el) return;
      const data=new Uint8Array(an.analyser.frequencyBinCount);
      an.analyser.getByteTimeDomainData(data);
      const rms=Math.sqrt(data.reduce((a,v)=>a+Math.pow((v-128)/128,2),0)/data.length);
      el.style.width=Math.min(100,rms*400)+'%';
    });
    // Oscilloscopes
    const now=performance.now()*0.001;
    Object.values(nodes).filter(n=>n.type==='oscilloscope').forEach(n=>{
      const an=audioNodes[n.id];
      const canvas=document.getElementById(n.id+'-scope');
      if(!an?.analyser||!canvas) return;
      const ctx=canvas.getContext('2d');
      const W=canvas.width, H=canvas.height;
      const data=new Uint8Array(an.analyser.fftSize);
      an.analyser.getByteTimeDomainData(data);
      const zoom=+nodes[n.id].params.zoom||1;
      const mode=nodes[n.id].params.mode||'standard';

      // Background / trail
      if(mode==='standard'){
        ctx.fillStyle='#000810'; ctx.fillRect(0,0,W,H);
      } else if(mode==='phosphor'){
        ctx.fillStyle='rgba(0,8,16,0.35)'; ctx.fillRect(0,0,W,H);
      } else { // trippy
        ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(0,0,W,H);
      }

      // Grid
      ctx.strokeStyle='rgba(0,100,40,0.25)'; ctx.lineWidth=0.5;
      for(let i=1;i<4;i++){
        ctx.beginPath(); ctx.moveTo(0,H*i/4); ctx.lineTo(W,H*i/4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(W*i/4,0); ctx.lineTo(W*i/4,H); ctx.stroke();
      }

      // Waveform ‚Äî find trigger point (zero crossing going up)
      let start=0;
      for(let i=1;i<data.length/2;i++){
        if(data[i-1]<128&&data[i]>=128){start=i;break;}
      }
      const visLen=Math.min(data.length-start, Math.floor(data.length/zoom));

      if(mode==='trippy'){
        // Ring buffer for echo effect ‚Äî keep last 10 frames
        if(!scopeHistory[n.id]) scopeHistory[n.id]=[];
        scopeHistory[n.id].push(new Uint8Array(data.buffer.slice(0)));
        if(scopeHistory[n.id].length>10) scopeHistory[n.id].shift();
        // Draw echoes oldest‚Üínewest at decreasing opacity
        scopeHistory[n.id].forEach((frame,fi,arr)=>{
          const age=arr.length-1-fi; // 0=newest
          const alpha=0.12+0.08*(arr.length-1-age)/arr.length;
          const hueShift=(fi/arr.length*120+now*60)%360;
          ctx.lineWidth=1.5; ctx.shadowBlur=0;
          let first=true;
          ctx.beginPath();
          for(let i=0;i<visLen;i++){
            const x=(i/visLen)*W;
            let y=H/2-(frame[start+i]-128)/128*(H/2)*0.9;
            y+=Math.sin(now*2+i*0.12+fi*0.8)*((frame[start+i]-128)/128)*(H/2)*0.12;
            first?ctx.moveTo(x,y):ctx.lineTo(x,y); first=false;
          }
          const hue=(hueShift+age*25)%360;
          ctx.strokeStyle=`hsla(${hue},100%,65%,${alpha+(fi===arr.length-1?0.7:0)})`;
          if(fi===arr.length-1){ ctx.lineWidth=2; ctx.shadowBlur=8; ctx.shadowColor=`hsl(${hue},100%,65%)`; }
          ctx.stroke(); ctx.shadowBlur=0;
        });
      } else if(mode==='phosphor'){
        // Chromatic aberration ‚Äî red channel shifted left
        ctx.beginPath(); ctx.strokeStyle='rgba(255,30,30,0.3)'; ctx.lineWidth=1;
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W-2;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Blue channel shifted right
        ctx.beginPath(); ctx.strokeStyle='rgba(30,180,255,0.3)'; ctx.lineWidth=1;
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W+2;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Wide soft outer glow pass
        ctx.beginPath(); ctx.strokeStyle='rgba(0,255,80,0.15)'; ctx.lineWidth=8;
        ctx.shadowBlur=20; ctx.shadowColor='#00ff55';
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Medium glow pass
        ctx.beginPath(); ctx.strokeStyle='rgba(0,255,80,0.4)'; ctx.lineWidth=3;
        ctx.shadowBlur=12; ctx.shadowColor='#00ff55';
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Bright core
        ctx.beginPath(); ctx.strokeStyle='#ccffdd'; ctx.lineWidth=1;
        ctx.shadowBlur=4; ctx.shadowColor='#00ff55';
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Scan lines artifact
        ctx.fillStyle='rgba(0,0,0,0.08)';
        for(let y=0;y<H;y+=2) ctx.fillRect(0,y,W,1);
        ctx.shadowBlur=0;
      } else {
        ctx.beginPath(); ctx.strokeStyle='#e0e0e0'; ctx.lineWidth=1.5; ctx.shadowBlur=0;
        for(let i=0;i<visLen;i++){
          const x=(i/visLen)*W;
          const y=H/2-(data[start+i]-128)/128*(H/2)*0.9;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
      }
      ctx.shadowBlur=0;
    });

    // Spectrum Analyzers
    Object.values(nodes).filter(n=>n.type==='spectrum').forEach(n=>{
      const an=audioNodes[n.id];
      const canvas=document.getElementById(n.id+'-scope');
      if(!an?.analyser||!canvas) return;
      const ctx=canvas.getContext('2d');
      const W=canvas.width, H=canvas.height;
      const mode=nodes[n.id].params.mode||'standard';
      const data=new Uint8Array(an.analyser.frequencyBinCount);
      an.analyser.getByteFrequencyData(data);
      const bins=Math.min(data.length, 128); // use first 128 bins for display

      if(mode==='standard'){
        ctx.fillStyle='#000810'; ctx.fillRect(0,0,W,H);
      } else if(mode==='phosphor'){
        ctx.fillStyle='rgba(0,8,16,0.35)'; ctx.fillRect(0,0,W,H);
      } else {
        ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(0,0,W,H);
      }
      // Grid
      ctx.strokeStyle='rgba(0,100,40,0.2)'; ctx.lineWidth=0.5;
      for(let i=1;i<4;i++){ctx.beginPath();ctx.moveTo(0,H*i/4);ctx.lineTo(W,H*i/4);ctx.stroke();}

      const bw=W/bins;
      if(mode==='phosphor'){
        // Draw bars with 3 passes: outer glow, mid, bright core + scan lines
        for(let i=0;i<bins;i++){
          const bh=(data[i]/255)*H, x=i*bw, y=H-bh;
          // Outer glow
          ctx.shadowBlur=12; ctx.shadowColor='#00ff55';
          ctx.fillStyle='rgba(0,255,80,0.15)';
          ctx.fillRect(x, y-2, bw, bh+2);
          // Mid
          ctx.shadowBlur=6;
          ctx.fillStyle='rgba(0,255,80,0.5)';
          ctx.fillRect(x+0.5, y, bw-1, bh);
          // Bright cap
          ctx.shadowBlur=3;
          ctx.fillStyle='#ccffdd';
          ctx.fillRect(x+0.5, y, bw-1, Math.min(2, bh));
        }
        // Scan lines
        ctx.shadowBlur=0; ctx.fillStyle='rgba(0,0,0,0.08)';
        for(let y=0;y<H;y+=2) ctx.fillRect(0,y,W,1);
      } else if(mode==='trippy'){
        // Echo: store frame, draw ghosts
        if(!scopeHistory[n.id]) scopeHistory[n.id]=[];
        scopeHistory[n.id].push(new Uint8Array(data.buffer.slice(0)));
        if(scopeHistory[n.id].length>8) scopeHistory[n.id].shift();
        scopeHistory[n.id].forEach((frame,fi,arr)=>{
          const age=arr.length-1-fi;
          const alpha=age===0?0.9:0.1+0.06*(arr.length-age)/arr.length;
          ctx.shadowBlur=age===0?8:0;
          for(let i=0;i<bins;i++){
            const bh=(frame[i]/255)*H, x=i*bw, y=H-bh;
            const hue=(i/bins*300+now*40+fi*35)%360;
            ctx.fillStyle=`hsla(${hue},100%,60%,${alpha})`;
            ctx.shadowColor=`hsl(${hue},100%,60%)`;
            ctx.fillRect(x+0.5, y, bw-1, bh);
          }
          ctx.shadowBlur=0;
        });
      } else {
        for(let i=0;i<bins;i++){
          const bh=(data[i]/255)*H, x=i*bw, y=H-bh;
          ctx.fillStyle='#00cc44';
          ctx.fillRect(x+0.5, y, bw-1, bh);
        }
      }
      ctx.shadowBlur=0;
    });

    // XY / Lissajous scopes
    Object.values(nodes).filter(n=>n.type==='xy_scope').forEach(n=>{
      const an=audioNodes[n.id];
      const canvas=document.getElementById(n.id+'-scope');
      if(!an?.analyserX||!canvas) return;
      const ctx=canvas.getContext('2d');
      const W=canvas.width, H=canvas.height;
      const mode=nodes[n.id].params.mode||'standard';
      const dataX=new Uint8Array(an.analyserX.fftSize);
      const dataY=new Uint8Array(an.analyserY.fftSize);
      an.analyserX.getByteTimeDomainData(dataX);
      an.analyserY.getByteTimeDomainData(dataY);
      const len=Math.min(dataX.length, dataY.length);

      // Grid
      ctx.strokeStyle='rgba(0,100,40,0.25)'; ctx.lineWidth=0.5;
      for(let i=1;i<4;i++){ctx.beginPath();ctx.moveTo(0,H*i/4);ctx.lineTo(W,H*i/4);ctx.stroke();ctx.beginPath();ctx.moveTo(W*i/4,0);ctx.lineTo(W*i/4,H);ctx.stroke();}

      const drawXYPath=(dx,dy,strokeStyle,lw,blur,blurColor)=>{
        ctx.beginPath(); ctx.strokeStyle=strokeStyle; ctx.lineWidth=lw;
        ctx.shadowBlur=blur; if(blurColor) ctx.shadowColor=blurColor;
        for(let i=0;i<len;i++){
          const x=((dx[i]-128)/128)*(W/2-2)+W/2;
          const y=((dy[i]-128)/128)*(H/2-2)+H/2;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke(); ctx.shadowBlur=0;
      };

      if(mode==='phosphor'){
        // Chromatic aberration ‚Äî red shifted left, blue shifted right
        ctx.beginPath(); ctx.strokeStyle='rgba(255,40,40,0.25)'; ctx.lineWidth=1; ctx.shadowBlur=0;
        for(let i=0;i<len;i++){
          const x=((dataX[i]-128)/128)*(W/2-2)+W/2-2;
          const y=((dataY[i]-128)/128)*(H/2-2)+H/2;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        ctx.beginPath(); ctx.strokeStyle='rgba(30,180,255,0.25)'; ctx.lineWidth=1; ctx.shadowBlur=0;
        for(let i=0;i<len;i++){
          const x=((dataX[i]-128)/128)*(W/2-2)+W/2+2;
          const y=((dataY[i]-128)/128)*(H/2-2)+H/2;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.stroke();
        // Outer glow
        drawXYPath(dataX,dataY,'rgba(0,255,80,0.15)',8,20,'#00ff55');
        // Mid glow
        drawXYPath(dataX,dataY,'rgba(0,255,80,0.45)',3,10,'#00ff55');
        // Bright core
        drawXYPath(dataX,dataY,'#ccffdd',1,4,'#00ff55');
        // Scan lines
        ctx.fillStyle='rgba(0,0,0,0.08)';
        for(let y=0;y<H;y+=2) ctx.fillRect(0,y,W,1);
      } else if(mode==='trippy'){
        if(!scopeHistory[n.id]) scopeHistory[n.id]=[];
        scopeHistory[n.id].push({x:new Uint8Array(dataX.buffer.slice(0)), y:new Uint8Array(dataY.buffer.slice(0))});
        if(scopeHistory[n.id].length>10) scopeHistory[n.id].shift();
        scopeHistory[n.id].forEach((frame,fi,arr)=>{
          const age=arr.length-1-fi;
          const alpha=age===0?0.85:0.08+0.06*(arr.length-age)/arr.length;
          const hue=(fi/arr.length*360+now*80)%360;
          ctx.beginPath();
          ctx.strokeStyle=`hsla(${hue},100%,65%,${alpha})`;
          ctx.lineWidth=age===0?2:1.5;
          ctx.shadowBlur=age===0?8:0; ctx.shadowColor=`hsl(${hue},100%,65%)`;
          for(let i=0;i<len;i++){
            const x=((frame.x[i]-128)/128)*(W/2-2)+W/2;
            const y=((frame.y[i]-128)/128)*(H/2-2)+H/2;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke(); ctx.shadowBlur=0;
        });
      } else {
        drawXYPath(dataX,dataY,'#00cc44',1.5,0);
      }
      ctx.shadowBlur=0;
    });

    // Stereo scopes
    Object.values(nodes).filter(n=>n.type==='stereo_scope').forEach(n=>{
      const an=audioNodes[n.id];
      const canvas=document.getElementById(n.id+'-scope');
      if(!an?.analyserL||!canvas) return;
      const ctx=canvas.getContext('2d');
      const W=canvas.width, H=canvas.height;
      const mode=nodes[n.id].params.mode||'standard';
      const dataL=new Uint8Array(an.analyserL.fftSize);
      const dataR=new Uint8Array(an.analyserR.fftSize);
      an.analyserL.getByteTimeDomainData(dataL);
      an.analyserR.getByteTimeDomainData(dataR);

      if(mode==='standard'){
        ctx.fillStyle='#000810'; ctx.fillRect(0,0,W,H);
      } else if(mode==='phosphor'){
        ctx.fillStyle='rgba(0,8,16,0.35)'; ctx.fillRect(0,0,W,H);
      } else {
        ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(0,0,W,H);
      }
      // Grid: horizontal center divider
      ctx.strokeStyle='rgba(0,100,40,0.3)'; ctx.lineWidth=0.5;
      ctx.beginPath(); ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.stroke();
      for(let i=1;i<4;i++){ctx.beginPath();ctx.moveTo(W*i/4,0);ctx.lineTo(W*i/4,H);ctx.stroke();}

      // Trippy: maintain history
      if(mode==='trippy'){
        if(!scopeHistory[n.id]) scopeHistory[n.id]=[];
        scopeHistory[n.id].push({L:new Uint8Array(dataL.buffer.slice(0)), R:new Uint8Array(dataR.buffer.slice(0))});
        if(scopeHistory[n.id].length>10) scopeHistory[n.id].shift();
      }

      // Draw L (top half) and R (bottom half)
      [[null,0,H/2,'L',0],[null,H/2,H,'R',1]].forEach(([_,y0,y1,ch,ci])=>{
        const hH=y1-y0;
        // find trigger in current data (used for all modes)
        const curData=ci===0?dataL:dataR;
        let start=0;
        for(let i=1;i<curData.length/2;i++){if(curData[i-1]<128&&curData[i]>=128){start=i;break;}}
        const vLen=Math.min(curData.length-start, curData.length);

        if(mode==='trippy'){
          // Draw echo frames
          (scopeHistory[n.id]||[]).forEach((frame,fi,arr)=>{
            const data=ci===0?frame.L:frame.R;
            const age=arr.length-1-fi;
            const alpha=age===0?0.85:0.08+0.05*(arr.length-age)/arr.length;
            const hue=(fi/arr.length*360+now*50+ci*140)%360;
            ctx.beginPath();
            ctx.strokeStyle=`hsla(${hue},100%,65%,${alpha})`;
            ctx.lineWidth=age===0?2:1.5;
            ctx.shadowBlur=age===0?8:0; ctx.shadowColor=`hsl(${hue},100%,65%)`;
            for(let i=0;i<vLen;i++){
              const x=(i/vLen)*W;
              let y=y0+hH/2-(data[start+i]-128)/128*(hH/2)*0.85;
              y+=Math.sin(now*1.3+i*0.08+fi*0.6+ci*3)*((data[start+i]-128)/128)*(hH/2)*0.12;
              i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
            }
            ctx.stroke(); ctx.shadowBlur=0;
          });
        } else if(mode==='phosphor'){
          const col=ci===0?'#00ffcc':'#ffaa00';
          const colRgb=ci===0?'0,255,200':'255,170,0';
          // Chromatic aberration
          ctx.beginPath(); ctx.strokeStyle=`rgba(255,40,40,0.2)`; ctx.lineWidth=1; ctx.shadowBlur=0;
          for(let i=0;i<vLen;i++){
            const x=(i/vLen)*W-1.5;
            const y=y0+hH/2-(curData[start+i]-128)/128*(hH/2)*0.85;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke();
          // Outer glow
          ctx.beginPath(); ctx.strokeStyle=`rgba(${colRgb},0.15)`; ctx.lineWidth=8; ctx.shadowBlur=16; ctx.shadowColor=col;
          for(let i=0;i<vLen;i++){
            const x=(i/vLen)*W; const y=y0+hH/2-(curData[start+i]-128)/128*(hH/2)*0.85;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke();
          // Mid
          ctx.beginPath(); ctx.strokeStyle=`rgba(${colRgb},0.5)`; ctx.lineWidth=2.5; ctx.shadowBlur=8; ctx.shadowColor=col;
          for(let i=0;i<vLen;i++){
            const x=(i/vLen)*W; const y=y0+hH/2-(curData[start+i]-128)/128*(hH/2)*0.85;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke();
          // Core
          ctx.beginPath(); ctx.strokeStyle='rgba(220,255,240,0.9)'; ctx.lineWidth=1; ctx.shadowBlur=3; ctx.shadowColor=col;
          for(let i=0;i<vLen;i++){
            const x=(i/vLen)*W; const y=y0+hH/2-(curData[start+i]-128)/128*(hH/2)*0.85;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke(); ctx.shadowBlur=0;
        } else {
          ctx.beginPath(); ctx.strokeStyle=ci===0?'#5da0d0':'#d6a058'; ctx.lineWidth=1.5; ctx.shadowBlur=0;
          for(let i=0;i<vLen;i++){
            const x=(i/vLen)*W; const y=y0+hH/2-(curData[start+i]-128)/128*(hH/2)*0.85;
            i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
          }
          ctx.stroke();
        }

        // Scan lines (phosphor only)
        if(mode==='phosphor'){
          ctx.fillStyle='rgba(0,0,0,0.07)';
          for(let y=y0;y<y1;y+=2) ctx.fillRect(0,y,W,1);
        }

        // Channel label
        ctx.fillStyle=mode==='standard'?(ci===0?'#5da0d0':'#d6a058'):'rgba(255,255,255,0.3)';
        ctx.font='7px monospace'; ctx.fillText(ch, 3, y0+9);
      });
    });
  }
  drawLoop();

  Object.keys(nodes).forEach(id=>document.getElementById(id)?.classList.add('running'));
  document.getElementById('play-btn').style.display='none';
  document.getElementById('stop-btn').style.display='inline-block';
  document.getElementById('status-msg').textContent='‚ñ∂ playing';
}

function stopAudio(){
  if(!audioCtx) return;
  if(rafId){cancelAnimationFrame(rafId);rafId=null;}
  // Stop sequencer intervals + clear step highlights
  Object.entries(seqState).forEach(([id,st])=>{
    clearInterval(st.intervalId);
    for(let i=0;i<8;i++) document.getElementById(`${id}-s${i}`)?.classList.remove('playing');
  });
  seqState={};
  Object.values(audioNodes).forEach(an=>{
    try{if(an.osc)an.osc.stop();else if(an.main?.stop)an.main.stop();}catch(e){}
    try{if(an.main?.disconnect)an.main.disconnect();}catch(e){}
  });
  audioCtx.close(); audioCtx=null; audioNodes={}; masterGain=null;
  scopeHistory={};
  // Clear scopes
  document.querySelectorAll('.scope-canvas').forEach(c=>{
    const ctx=c.getContext('2d'); ctx.fillStyle='#000810'; ctx.fillRect(0,0,c.width,c.height);
  });
  document.querySelectorAll('.vu-fill').forEach(el=>el.style.width='0%');
  Object.keys(nodes).forEach(id=>document.getElementById(id)?.classList.remove('running'));
  document.getElementById('play-btn').style.display='inline-block';
  document.getElementById('stop-btn').style.display='none';
  document.getElementById('status-msg').textContent='';
}

// ‚îÄ‚îÄ‚îÄ Presets ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loadPreset(name){
  if(!name) return;
  // User-saved preset
  if (name.startsWith('user:')) {
    const key = name.slice(5);
    const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
    if (saved[key]) { loadUserPreset(saved[key]); setActivePreset(key); }
    return;
  }
  setActivePreset(null);
  clearAll();
  switch(name){

    case'drone': {
      // Simple hypnotic drone ‚Äî detuned oscillators + filter sweep
      const o1 = createNode('oscillator', 60, 80, {freq:110,wave:'sawtooth'});
      const o2 = createNode('oscillator', 60,230, {freq:110.5,wave:'sawtooth'});
      const g1 = createNode('gain', 290,100, {gain:0.4});
      const g2 = createNode('gain', 290,230, {gain:0.4});
      const flt= createNode('filter', 500,160, {type:'lowpass',freq:600,q:3});
      const lfo= createNode('lfo',   500,320, {freq:0.2,depth:400});
      const spk= createNode('speaker',720,160);
      const scp= createNode('oscilloscope',720,280);
      setTimeout(()=>{
        addEdge(o1,'signal',g1,'signal'); addEdge(o2,'signal',g2,'signal');
        addEdge(g1,'signal',flt,'signal'); addEdge(g2,'signal',flt,'signal');
        addEdge(flt,'signal',spk,'signal'); addEdge(flt,'signal',scp,'signal');
        addEdge(lfo,'mod',flt,'freq_mod');
        renderEdges();
      },50); break;
    }

    case'wobble': {
      // Classic acid bass ‚Äî square wave through resonant filter, fast LFO
      const osc = createNode('oscillator', 60,100, {freq:80,wave:'square'});
      const flt = createNode('filter',     290,80, {type:'lowpass',freq:300,q:8});
      const dis = createNode('distortion', 500,80, {amount:30});
      const gain= createNode('gain',       700,80, {gain:0.5});
      const lfo = createNode('lfo',        290,270,{freq:1.5,depth:600});
      const spk = createNode('speaker',    700,220);
      const scp = createNode('oscilloscope',700,360);
      setTimeout(()=>{
        addEdge(osc,'signal',flt,'signal'); addEdge(flt,'signal',dis,'signal');
        addEdge(dis,'signal',gain,'signal'); addEdge(gain,'signal',spk,'signal');
        addEdge(gain,'signal',scp,'signal'); addEdge(lfo,'mod',flt,'freq_mod');
        renderEdges();
      },50); break;
    }

    case'space': {
      // Spacious ambient ‚Äî sine through long delay + reverb + scope
      const osc = createNode('oscillator', 60,120, {freq:220,wave:'sine'});
      const g1  = createNode('gain',       270,120,{gain:0.7});
      const del = createNode('delay',      460,80, {time:0.6,feedback:0.65});
      const rev = createNode('reverb',     460,240,{duration:4,decay:3,wet:0.6});
      const g2  = createNode('gain',       680,160,{gain:0.35});
      const lfo = createNode('lfo',        60, 290,{freq:0.15,depth:30});
      const spk = createNode('speaker',    680,300);
      const scp = createNode('oscilloscope',460,400);
      setTimeout(()=>{
        addEdge(osc,'signal',g1,'signal'); addEdge(g1,'signal',del,'signal');
        addEdge(del,'signal',rev,'signal'); addEdge(rev,'signal',g2,'signal');
        addEdge(g2,'signal',spk,'signal'); addEdge(g2,'signal',scp,'signal');
        addEdge(lfo,'mod',osc,'freq_mod');
        renderEdges();
      },50); break;
    }

    case'fuzz': {
      // Fuzz lead ‚Äî sawtooth with fast LFO on filter + heavy distortion + compression
      const osc = createNode('oscillator', 60, 80, {freq:220,wave:'sawtooth'});
      const flt = createNode('filter',     280, 60,{type:'lowpass',freq:2000,q:3});
      const dis = createNode('distortion', 490, 60,{amount:180});
      const cmp = createNode('compressor', 700, 60,{threshold:-24,ratio:8,knee:6});
      const gain= createNode('gain',       700,210,{gain:0.45});
      const lfo = createNode('lfo',        280,240,{freq:5,depth:1800});
      const spk = createNode('speaker',    700,340);
      const scp = createNode('oscilloscope',490,260);
      setTimeout(()=>{
        addEdge(osc,'signal',flt,'signal'); addEdge(flt,'signal',dis,'signal');
        addEdge(dis,'signal',cmp,'signal'); addEdge(cmp,'signal',gain,'signal');
        addEdge(gain,'signal',spk,'signal'); addEdge(dis,'signal',scp,'signal');
        addEdge(lfo,'mod',flt,'freq_mod');
        renderEdges();
      },50); break;
    }

    case'arpseq': {
      // Step sequencer ‚Üí square osc ‚Üí filter ‚Üí delay ‚Üí gain ‚Üí speaker + scope
      // seq ‚Üí osc ‚Üí filter ‚Üí delay ‚Üí speaker;  filter also ‚Üí scope
      const seq = createNode('sequencer',  30,  30, {bpm:140});
      const osc = createNode('oscillator', 340,  30, {freq:220, wave:'square'});
      const flt = createNode('filter',     560,  30, {type:'lowpass', freq:800, q:6});
      const del = createNode('delay',      560, 220, {time:0.21, feedback:0.35});
      const spk = createNode('speaker',    780, 100);
      const scp = createNode('oscilloscope', 780, 260);
      setTimeout(()=>{
        addEdge(seq,'freq',  osc,'freq');
        addEdge(osc,'signal', flt,'signal');
        addEdge(flt,'signal', del,'signal');
        addEdge(del,'signal', spk,'signal');
        addEdge(flt,'signal', scp,'signal');
        renderEdges();
      },50); break;
    }

    case'stereopan': {
      // Two detuned oscillators panned hard L/R ‚Äî classic stereo widening
      // Osc A (sine 220Hz) ‚Üí Pan L ‚Üí Speaker
      // Osc B (triangle 329Hz) ‚Üí Pan R ‚Üí Speaker
      // LFO gently drifts Pan A for slow movement
      // Stereo scope: L ‚Üê Pan A, R ‚Üê Pan B
      const oscA  = createNode('oscillator',  60,  60, {freq:220, wave:'sine'});
      const panA  = createNode('pan',         280,  60, {pan:-0.75});
      const oscB  = createNode('oscillator',  60, 230, {freq:329.6, wave:'triangle'});
      const panB  = createNode('pan',         280, 230, {pan:0.75});
      const lfo   = createNode('lfo',         60,  400, {freq:0.2, depth:0.4});
      const spk   = createNode('speaker',     500, 145);
      const scp   = createNode('stereo_scope',500, 300, {mode:'phosphor'});
      setTimeout(()=>{
        addEdge(oscA,'signal', panA,'signal');
        addEdge(oscB,'signal', panB,'signal');
        addEdge(panA,'signal', spk,'signal');
        addEdge(panB,'signal', spk,'signal');
        addEdge(panA,'signal', scp,'L');
        addEdge(panB,'signal', scp,'R');
        addEdge(lfo,'mod',     panA,'pan_mod'); // LFO drifts pan A slowly
        renderEdges();
      },50); break;
    }

    case'pingpong': {
      // Sawtooth through ping-pong delay ‚Äî classic stereo bounce effect
      // Dry signal + bounced echoes alternate L and R
      const osc  = createNode('oscillator',  60, 100, {freq:220, wave:'sawtooth'});
      const gain = createNode('gain',        260, 100, {gain:0.6});
      const pp   = createNode('ping_pong',   460,  60, {timeL:0.3, timeR:0.6, feedback:0.45, wet:0.6});
      const spk  = createNode('speaker',     700, 100);
      const lfo  = createNode('lfo',         60,  280, {freq:0.08, depth:40});
      const scp  = createNode('stereo_scope',700, 260, {mode:'phosphor'});
      setTimeout(()=>{
        addEdge(osc,'signal',  gain,'signal');
        addEdge(gain,'signal', pp,'signal');
        addEdge(pp,'signal',   spk,'signal');
        addEdge(pp,'signal',   scp,'L');
        addEdge(pp,'signal',   scp,'R');
        addEdge(lfo,'mod',     osc,'freq_mod');
        renderEdges();
      },50); break;
    }

    case'keyjam': {
      // Keyboard ‚Üí sawtooth ‚Üí filter ‚Üí reverb ‚Üí speaker
      // Play notes with mouse clicks or QWERTY keys
      const kb   = createNode('keyboard',    30,  80);
      const osc  = createNode('oscillator',  280,  80, {freq:261.6, wave:'sawtooth'});
      const flt  = createNode('filter',      490,  80, {type:'lowpass', freq:1200, q:4});
      const rev  = createNode('reverb',      490, 250, {duration:2, decay:1.5, wet:0.35});
      const spk  = createNode('speaker',     700, 165);
      const scp  = createNode('oscilloscope',700, 310, {mode:'phosphor'});
      setTimeout(()=>{
        addEdge(kb,'freq',    osc,'freq');
        addEdge(osc,'signal', flt,'signal');
        addEdge(flt,'signal', rev,'signal');
        addEdge(rev,'signal', spk,'signal');
        addEdge(flt,'signal', scp,'signal');
        renderEdges();
      },50); break;
    }
  }
}

// ‚îÄ‚îÄ‚îÄ Auto Arrange ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function autoArrange() {
  const ids = Object.keys(nodes);
  if (!ids.length) return;

  // Longest-path depth assignment
  const depth = {};
  ids.forEach(id => depth[id] = 0);
  for (let pass = 0; pass < ids.length; pass++) {
    edges.forEach(e => {
      if (nodes[e.srcNode] && nodes[e.dstNode]) {
        const d = (depth[e.srcNode] || 0) + 1;
        if (d > depth[e.dstNode]) depth[e.dstNode] = d;
      }
    });
  }

  // Group by column depth
  const cols = {};
  ids.forEach(id => {
    const d = depth[id] || 0;
    if (!cols[d]) cols[d] = [];
    cols[d].push(id);
  });

  const colKeys = Object.keys(cols).sort((a,b) => a - b);
  const PAD = 24, MIN_GAP_X = 12, MAX_GAP_X = 48, MIN_GAP_Y = 10, MAX_GAP_Y = 28;
  const canvasW = canvasEl.clientWidth  || 900;
  const canvasH = canvasEl.clientHeight || 600;
  const availW  = canvasW - PAD * 2;
  const availH  = canvasH - PAD * 2;

  // Measure each node's rendered size
  const nW = {}, nH = {};
  ids.forEach(id => {
    const el = document.getElementById(id);
    nW[id] = el ? el.offsetWidth  : 180;
    nH[id] = el ? el.offsetHeight : 140;
  });

  // Max width per column
  const colMaxW = {};
  colKeys.forEach(col => colMaxW[col] = Math.max(...cols[col].map(id => nW[id])));

  // Column gap: fit first, then cap ‚Äî don't blow out spacing when few columns
  const totalNodeW = colKeys.reduce((s,c) => s + colMaxW[c], 0);
  const numColGaps = colKeys.length - 1;
  // If content is wider than viewport, let gap shrink to 0 (nodes touch but stay visible)
  const naturalColGap = numColGaps > 0 ? (availW - totalNodeW) / numColGaps : 0;
  const colGap = Math.min(MAX_GAP_X, Math.max(0, naturalColGap));

  // Compute x positions ‚Äî pack from top-left
  const colX = {};
  let curX = PAD;
  colKeys.forEach(col => { colX[col] = curX; curX += colMaxW[col] + colGap; });

  // Per-column: pack rows from top with capped gap
  colKeys.forEach(col => {
    const colNodes = cols[col];
    const heights  = colNodes.map(id => nH[id]);
    const totalNodeH = heights.reduce((a,b) => a+b, 0);
    const numRowGaps = colNodes.length - 1;
    const naturalRowGap = numRowGaps > 0 ? (availH - totalNodeH) / numRowGaps : 0;
    const rowGap = Math.min(MAX_GAP_Y, Math.max(MIN_GAP_Y, naturalRowGap));
    let y = PAD;

    colNodes.forEach((id, ri) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.style.left = colX[col] + 'px';
      el.style.top  = y + 'px';
      nodes[id].x = colX[col];
      nodes[id].y = y;
      y += heights[ri] + rowGap;
    });
  });

  // Scale canvas down if content doesn't fit
  const maxX = Math.max(...ids.map(id => nodes[id].x + nW[id])) + PAD;
  const maxY = Math.max(...ids.map(id => nodes[id].y + nH[id])) + PAD;
  canvasScale = Math.min(1, canvasW / maxX, canvasH / maxY);
  canvasEl.style.transformOrigin = '0 0';
  canvasEl.style.transform = canvasScale < 0.999 ? `scale(${canvasScale.toFixed(4)})` : '';

  renderEdges();
}

function resetCanvasScale() {
  if (canvasScale >= 0.999) return;
  canvasScale = 1.0;
  canvasEl.style.transform = '';
}

// ‚îÄ‚îÄ‚îÄ User Presets (localStorage) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const STORAGE_KEY = 'synth-user-presets';
let activeUserPreset = null;

function setActivePreset(name) {
  activeUserPreset = name || null;
  const isUser = !!activeUserPreset;
  const del = document.getElementById('btn-delete');
  if (del) { del.disabled = !isUser; del.style.opacity = isUser ? '1' : '0.4'; }
}

function serializeGraph() {
  return {
    nodes: Object.values(nodes).map(n => ({
      id: n.id, type: n.type, x: n.x, y: n.y,
      params: JSON.parse(JSON.stringify(n.params))
    })),
    edges: edges.map(e => ({ ...e }))
  };
}

function persistPreset(key) {
  const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
  saved[key] = { name: key, ...serializeGraph() };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
}

function savePreset() {
  const name = prompt('Save preset:', activeUserPreset || '');
  if (!name || !name.trim()) return;
  const key = name.trim();
  const isOverwrite = key === activeUserPreset;
  persistPreset(key);
  addUserPresetOption(key);
  setActivePreset(key);
  const msg = isOverwrite ? `‚úì updated "${key}"` : `‚úì saved "${key}"`;
  document.getElementById('status-msg').textContent = msg;
  setTimeout(() => document.getElementById('status-msg').textContent = '', 2000);
}

function deleteCurrentPreset() {
  if (!activeUserPreset) return;
  if (!confirm(`Delete preset "${activeUserPreset}"?`)) return;
  const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
  delete saved[activeUserPreset];
  localStorage.setItem(STORAGE_KEY, JSON.stringify(saved));
  // Remove from dropdown
  const group = document.getElementById('user-preset-group');
  group.querySelector(`option[value="user:${activeUserPreset}"]`)?.remove();
  setActivePreset(null);
  document.getElementById('status-msg').textContent = `Deleted`;
  setTimeout(() => document.getElementById('status-msg').textContent = '', 2000);
}

function addUserPresetOption(name) {
  const group = document.getElementById('user-preset-group');
  if (group.querySelector(`option[value="user:${name}"]`)) return;
  const opt = document.createElement('option');
  opt.value = 'user:' + name;
  opt.textContent = name;
  group.appendChild(opt);
}

function loadUserPreset(data) {
  clearAll();
  const idMap = {};
  // Restore nodes with original positions
  data.nodes.forEach(n => {
    const newId = createNode(n.type, n.x, n.y, n.params);
    idMap[n.id] = newId;
  });
  setTimeout(() => {
    data.edges.forEach(e => {
      const src = idMap[e.srcNode], dst = idMap[e.dstNode];
      if (src && dst) addEdge(src, e.srcPort, dst, e.dstPort);
    });
    renderEdges();
  }, 50);
}

function populateUserPresets() {
  const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
  Object.keys(saved).forEach(name => addUserPresetOption(name));
}

// ‚îÄ‚îÄ‚îÄ Utility ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateStats(){
  document.getElementById('stat-nodes').textContent=Object.keys(nodes).length;
  document.getElementById('stat-edges').textContent=edges.length;
}
function clearAll(){
  stopAudio();
  Object.keys(nodes).forEach(id=>document.getElementById(id)?.remove());
  nodes={}; edges=[]; nodeIdCounter=0;
  setActivePreset(null);
  resetCanvasScale();
  renderEdges(); updateStats();
}

// ‚îÄ‚îÄ‚îÄ Scroll-to-adjust number inputs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.addEventListener('wheel', e => {
  const el = e.target;
  if (el.tagName !== 'INPUT' || el.type !== 'number') return;
  e.preventDefault();
  const step = parseFloat(el.step) || 1;
  const min  = el.min !== '' ? parseFloat(el.min)  : -Infinity;
  const max  = el.max !== '' ? parseFloat(el.max)  :  Infinity;
  const dir  = e.deltaY < 0 ? 1 : -1;
  const newVal = Math.min(max, Math.max(min, parseFloat(el.value) + step * dir));
  // round to same decimal places as step to avoid float noise
  const decimals = (step.toString().split('.')[1] || '').length;
  el.value = newVal.toFixed(decimals);
  el.dispatchEvent(new Event('change', { bubbles: true }));
}, { passive: false });

// ‚îÄ‚îÄ‚îÄ Perf Monitor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(function perfLoop() {
  const canvas = document.getElementById('perf-canvas');
  const ctx2   = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const history = new Array(W).fill(0);
  let lastT = performance.now(), frameCount = 0, fps = 0;
  const hasHeap = !!(performance.memory);
  if (hasHeap) document.getElementById('perf-heap-row').style.display = 'flex';

  function tick(now) {
    requestAnimationFrame(tick);
    frameCount++;
    const elapsed = now - lastT;
    if (elapsed >= 500) {
      fps = Math.round(frameCount / elapsed * 1000);
      frameCount = 0; lastT = now;
      document.getElementById('perf-fps').textContent = fps;
      if (hasHeap) {
        const mb = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
        document.getElementById('perf-heap').textContent = mb + ' MB';
      }
    }
    // sparkline: fps normalised 0‚Äì60
    history.push(Math.min(fps, 60));
    if (history.length > W) history.shift();

    ctx2.clearRect(0, 0, W, H);
    // grid line at 30fps
    ctx2.strokeStyle = 'rgba(48,54,61,0.8)'; ctx2.lineWidth = 0.5;
    ctx2.beginPath(); ctx2.moveTo(0, H/2); ctx2.lineTo(W, H/2); ctx2.stroke();

    // sparkline
    ctx2.beginPath();
    ctx2.strokeStyle = fps >= 55 ? '#58d68d' : fps >= 30 ? '#d6a058' : '#f85149';
    ctx2.lineWidth = 1.5;
    history.forEach((v, i) => {
      const x = i, y = H - (v / 60) * (H - 2) - 1;
      i === 0 ? ctx2.moveTo(x, y) : ctx2.lineTo(x, y);
    });
    ctx2.stroke();

    // fill under line
    ctx2.lineTo(W, H); ctx2.lineTo(0, H); ctx2.closePath();
    ctx2.fillStyle = fps >= 55 ? 'rgba(88,214,141,0.08)' : fps >= 30 ? 'rgba(214,160,88,0.08)' : 'rgba(248,81,73,0.08)';
    ctx2.fill();
  }
  requestAnimationFrame(tick);
})();

// ‚îÄ‚îÄ‚îÄ Help Modal ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const HELP_SEEN_KEY='synth_html_help_seen';
function toggleHelp(){
  const el=document.getElementById('help-overlay');
  const shown=el.style.display==='flex';
  el.style.display=shown?'none':'flex';
  if(!shown) localStorage.setItem(HELP_SEEN_KEY,'1');
}
function closeHelp(){
  document.getElementById('help-overlay').style.display='none';
  localStorage.setItem(HELP_SEEN_KEY,'1');
}
document.addEventListener('keydown',e=>{
  if(e.key==='Escape') closeHelp();
});
document.getElementById('help-overlay').addEventListener('click',e=>{
  if(e.target===e.currentTarget) closeHelp();
});

// ‚îÄ‚îÄ‚îÄ Share / URL encoding ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function shareLink() {
  const graph = serializeGraph();
  const suggestedName = activeUserPreset || '';
  const name = prompt('Patch name:', suggestedName);
  if (name === null) return; // cancelled
  const payload = { name: name.trim(), ...graph };
  const encoded = btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
  const url = location.href.split('#')[0] + '#patch=' + encoded;

  // Try clipboard API (works on HTTPS / localhost)
  const tryClipboard = navigator.clipboard?.writeText?.(url);
  if (tryClipboard) {
    tryClipboard.then(() => {
      document.getElementById('status-msg').textContent = '‚úì link copied!';
      setTimeout(() => document.getElementById('status-msg').textContent = '', 2500);
    }).catch(() => copyFallback(url));
  } else {
    copyFallback(url);
  }
}

function copyFallback(url) {
  // execCommand fallback (works on file://)
  const ta = document.createElement('textarea');
  ta.value = url;
  ta.style.cssText = 'position:fixed;opacity:0;top:0;left:0';
  document.body.appendChild(ta);
  ta.focus(); ta.select();
  try {
    const ok = document.execCommand('copy');
    document.getElementById('status-msg').textContent = ok ? '‚úì link copied!' : '‚ö† copy failed';
  } catch(e) {
    prompt('Copy this link:', url);
  }
  document.body.removeChild(ta);
  setTimeout(() => document.getElementById('status-msg').textContent = '', 2500);
}

function loadFromHash() {
  const hash = location.hash;
  if (!hash.startsWith('#patch=')) return;
  try {
    const encoded = hash.slice(7);
    const payload = JSON.parse(decodeURIComponent(escape(atob(encoded))));
    const { name, nodes: ns, edges: es } = payload;
    loadUserPreset({ nodes: ns, edges: es });
    if (name) {
      document.getElementById('status-msg').textContent = `‚Üó loaded "${name}"`;
      setTimeout(() => document.getElementById('status-msg').textContent = '', 3000);
    }
    // stash name so Save can use it
    if (name) setActivePreset(name);
  } catch(e) {
    console.warn('Failed to load patch from URL:', e);
  }
}

// ‚îÄ‚îÄ‚îÄ QWERTY keyboard ‚Üí keyboard node ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const QWERTY_MAP = {
  'a':0,'w':1,'s':2,'e':3,'d':4,'f':5,'t':6,'g':7,'y':8,'h':9,'u':10,'j':11,'k':12
};
document.addEventListener('keydown', e => {
  if (e.repeat || e.target.tagName==='INPUT' || e.target.tagName==='SELECT') return;
  if (e.key === '-') {
    if (activeKbNode && nodes[activeKbNode]) {
      nodes[activeKbNode].params.octave = Math.max(1, +nodes[activeKbNode].params.octave - 1);
      updateParam(activeKbNode,'octave',nodes[activeKbNode].params.octave);
    }
    return;
  }
  if (e.key === '=') {
    if (activeKbNode && nodes[activeKbNode]) {
      nodes[activeKbNode].params.octave = Math.min(7, +nodes[activeKbNode].params.octave + 1);
      updateParam(activeKbNode,'octave',nodes[activeKbNode].params.octave);
    }
    return;
  }
  const semi = QWERTY_MAP[e.key.toLowerCase()];
  if (semi === undefined) return;
  if (!activeKbNode) {
    const kbn = Object.values(nodes).find(n => n.type==='keyboard');
    if (kbn) activeKbNode = kbn.id;
  }
  if (activeKbNode) kbPress(activeKbNode, semi);
});
document.addEventListener('keyup', e => {
  const semi = QWERTY_MAP[e.key.toLowerCase()];
  if (semi !== undefined && activeKbNode) kbRelease(activeKbNode, semi);
});

// ‚îÄ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
populateUserPresets();
// Load from URL hash first; fall back to default preset
if (location.hash.startsWith('#patch=')) {
  loadFromHash();
} else {
  loadPreset('wobble');
}
// Show help on first ever visit
if(!localStorage.getItem(HELP_SEEN_KEY)){
  setTimeout(()=>{ document.getElementById('help-overlay').style.display='flex'; }, 400);
}
</script>
</body>
</html>
